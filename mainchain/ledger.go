// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package mainchain

import (
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = abi.U256
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// CelerLedgerABI is the input ABI used to generate the binding from.
const CelerLedgerABI = "[{\"constant\":true,\"inputs\":[],\"name\":\"tmpChannelId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tmpChannelIds\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ethPool\",\"type\":\"address\"},{\"name\":\"_payRegistry\",\"type\":\"address\"},{\"name\":\"_celerWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"tokenType\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"peerAddrs\",\"type\":\"address[2]\"},{\"indexed\":false,\"name\":\"initialDeposits\",\"type\":\"uint256[2]\"}],\"name\":\"OpenChannel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"peerAddrs\",\"type\":\"address[2]\"},{\"indexed\":false,\"name\":\"deposits\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"withdrawals\",\"type\":\"uint256[2]\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"seqNums\",\"type\":\"uint256[2]\"}],\"name\":\"SnapshotStates\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"seqNums\",\"type\":\"uint256[2]\"}],\"name\":\"IntendSettle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"payId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"peerFrom\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClearOnePay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"settleBalance\",\"type\":\"uint256[2]\"}],\"name\":\"ConfirmSettle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"}],\"name\":\"ConfirmSettleFail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"IntendWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"recipientChannelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"deposits\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"withdrawals\",\"type\":\"uint256[2]\"}],\"name\":\"ConfirmWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"}],\"name\":\"VetoWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"recipientChannelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"deposits\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"withdrawals\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"seqNum\",\"type\":\"uint256\"}],\"name\":\"CooperativeWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"settleBalance\",\"type\":\"uint256[2]\"}],\"name\":\"CooperativeSettle\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"},{\"name\":\"_disputeTimeout\",\"type\":\"uint256\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_tokenType\",\"type\":\"uint256\"},{\"name\":\"_peerAddrs\",\"type\":\"address[2]\"},{\"name\":\"_deposits\",\"type\":\"uint256[2]\"}],\"name\":\"openChannelMockSet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_openRequest\",\"type\":\"bytes\"}],\"name\":\"openChannel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_transferFromAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_channelIds\",\"type\":\"bytes32[]\"},{\"name\":\"_peerFroms\",\"type\":\"address[]\"},{\"name\":\"_seqNums\",\"type\":\"uint256[]\"},{\"name\":\"_transferOuts\",\"type\":\"uint256[]\"},{\"name\":\"_pendingPayOuts\",\"type\":\"uint256[]\"}],\"name\":\"snapshotStatesMockSet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signedSimplexStateArray\",\"type\":\"bytes\"}],\"name\":\"snapshotStates\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_recipientChannelId\",\"type\":\"bytes32\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"intendWithdrawMockSet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_recipientChannelId\",\"type\":\"bytes32\"}],\"name\":\"intendWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"}],\"name\":\"confirmWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"}],\"name\":\"vetoWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"},{\"name\":\"_peerFrom\",\"type\":\"address\"},{\"name\":\"_seqNum\",\"type\":\"uint256\"},{\"name\":\"_transferOut\",\"type\":\"uint256\"},{\"name\":\"_nextPayIdListHash\",\"type\":\"bytes32\"},{\"name\":\"_lastPayResolveDeadline\",\"type\":\"uint256\"},{\"name\":\"_pendingPayOut\",\"type\":\"uint256\"}],\"name\":\"intendSettleMockSet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signedSimplexStateArray\",\"type\":\"bytes\"}],\"name\":\"intendSettle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signedSimplexStateArray\",\"type\":\"bytes\"}],\"name\":\"intendSettleRevert\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"}],\"name\":\"confirmSettle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"}],\"name\":\"getSettleFinalizedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"}],\"name\":\"getTokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"}],\"name\":\"getTokenType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"}],\"name\":\"getChannelStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"}],\"name\":\"getCooperativeWithdrawSeqNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"}],\"name\":\"getTotalBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"}],\"name\":\"getBalanceMap\",\"outputs\":[{\"name\":\"\",\"type\":\"address[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"}],\"name\":\"getChannelMigrationArgs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"}],\"name\":\"getPeersMigrationInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"address[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"}],\"name\":\"getDisputeTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"}],\"name\":\"getMigratedTo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"}],\"name\":\"getStateSeqNumMap\",\"outputs\":[{\"name\":\"\",\"type\":\"address[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"}],\"name\":\"getTransferOutMap\",\"outputs\":[{\"name\":\"\",\"type\":\"address[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"}],\"name\":\"getNextPayIdListHashMap\",\"outputs\":[{\"name\":\"\",\"type\":\"address[2]\"},{\"name\":\"\",\"type\":\"bytes32[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"}],\"name\":\"getLastPayResolveDeadlineMap\",\"outputs\":[{\"name\":\"\",\"type\":\"address[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"}],\"name\":\"getPendingPayOutMap\",\"outputs\":[{\"name\":\"\",\"type\":\"address[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_channelId\",\"type\":\"bytes32\"}],\"name\":\"getWithdrawIntent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_channelStatus\",\"type\":\"uint256\"}],\"name\":\"getChannelStatusNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEthPool\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPayRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCelerWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"getBalanceLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalanceLimitsEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]"

// CelerLedgerBin is the compiled bytecode used for deploying new contracts.
const CelerLedgerBin = `0x608060405234801561001057600080fd5b50604051612c15380380612c158339818101604052606081101561003357600080fd5b508051602082015160409092015160018054600160a060020a0319908116600160a060020a03948516178255600280548216958516959095179094556003805490941692909116919091179091556005805460ff19169091179055612b788061009d6000396000f3fe6080604052600436106102295760003560e060020a90048063979a9b5e11610127578063cd3a1be6116100af578063e6322df711610073578063e6322df714610d1f578063e803255714610d49578063ec7c637d14610d99578063eff3417c14610dcc578063f0c73d7014610e2357610229565b8063cd3a1be614610c5a578063d4e3680f14610c84578063d75f960e14610cae578063d927bfc414610cc3578063d954863c14610ced57610229565b8063b962a1d8116100f6578063b962a1d814610afa578063bd480cb714610b0f578063c38a325d14610bcc578063c7ff862514610bf6578063cc0b94b714610c2057610229565b8063979a9b5e146109f05780639f1fad8314610a3e578063a099a39f14610a68578063a979e22914610a7d57610229565b8063312ea2c6116101b55780637e9a7a3e116101795780637e9a7a3e1461079a57806388f41465146107c45780638942ecb2146109055780638f16cef41461093b57806393b7b3ce1461098057610229565b8063312ea2c61461065a5780634102b9a81461066f578063666a6d65146106ec57806369d5dd671461071657806376bff1171461074057610229565b8063255aab59116101fc578063255aab591461053f5780632b559ecc146105695780632e2a5a02146105925780632f0ac304146105d8578063307d6f961461063057610229565b80630165cef81461022e57806309b65d86146102bf578063130d33fe146102fb57806314ff14911461037a575b600080fd5b34801561023a57600080fd5b506102586004803603602081101561025157600080fd5b5035610e4d565b6040518083600260200280838360005b83811015610280578181015183820152602001610268565b5050505090500182600260200280838360005b838110156102ab578181015183820152602001610293565b505050509050019250505060405180910390f35b3480156102cb57600080fd5b506102e9600480360360208110156102e257600080fd5b5035610f22565b60408051918252519081900360200190f35b34801561030757600080fd5b506103786004803603602081101561031e57600080fd5b81019060208101813564010000000081111561033957600080fd5b82018360208201111561034b57600080fd5b8035906020019184600183028401116401000000008311171561036d57600080fd5b509092509050610fcd565b005b34801561038657600080fd5b50610378600480360360a081101561039d57600080fd5b8101906020810181356401000000008111156103b857600080fd5b8201836020820111156103ca57600080fd5b803590602001918460208302840111640100000000831117156103ec57600080fd5b91939092909160208101903564010000000081111561040a57600080fd5b82018360208201111561041c57600080fd5b8035906020019184602083028401116401000000008311171561043e57600080fd5b91939092909160208101903564010000000081111561045c57600080fd5b82018360208201111561046e57600080fd5b8035906020019184602083028401116401000000008311171561049057600080fd5b9193909290916020810190356401000000008111156104ae57600080fd5b8201836020820111156104c057600080fd5b803590602001918460208302840111640100000000831117156104e257600080fd5b91939092909160208101903564010000000081111561050057600080fd5b82018360208201111561051257600080fd5b8035906020019184602083028401116401000000008311171561053457600080fd5b509092509050611048565b34801561054b57600080fd5b506103786004803603602081101561056257600080fd5b503561113d565b34801561057557600080fd5b5061057e6112dd565b604080519115158252519081900360200190f35b34801561059e57600080fd5b506105bc600480360360208110156105b557600080fd5b50356112e7565b60408051600160a060020a039092168252519081900360200190f35b3480156105e457600080fd5b50610602600480360360208110156105fb57600080fd5b503561135f565b604080519485526020850193909352600160a060020a03909116838301526060830152519081900360800190f35b34801561063c57600080fd5b506102e96004803603602081101561065357600080fd5b503561142d565b34801561066657600080fd5b506105bc61143f565b34801561067b57600080fd5b506103786004803603602081101561069257600080fd5b8101906020810181356401000000008111156106ad57600080fd5b8201836020820111156106bf57600080fd5b803590602001918460018302840111640100000000831117156106e157600080fd5b50909250905061144e565b3480156106f857600080fd5b506102586004803603602081101561070f57600080fd5b5035611515565b34801561072257600080fd5b506102e96004803603602081101561073957600080fd5b50356115a1565b34801561074c57600080fd5b5061076a6004803603602081101561076357600080fd5b5035611619565b60408051600160a060020a0390951685526020850193909352838301919091526060830152519081900360800190f35b3480156107a657600080fd5b50610378600480360360208110156107bd57600080fd5b503561169a565b3480156107d057600080fd5b506107ee600480360360208110156107e757600080fd5b5035611859565b6040518087600260200280838360005b838110156108165781810151838201526020016107fe565b5050505090500186600260200280838360005b83811015610841578181015183820152602001610829565b5050505090500185600260200280838360005b8381101561086c578181015183820152602001610854565b5050505090500184600260200280838360005b8381101561089757818101518382015260200161087f565b5050505090500183600260200280838360005b838110156108c25781810151838201526020016108aa565b5050505090500182600260200280838360005b838110156108ed5781810151838201526020016108d5565b50505050905001965050505050505060405180910390f35b34801561091157600080fd5b506103786004803603606081101561092857600080fd5b5080359060208101359060400135611968565b34801561094757600080fd5b506103786004803603608081101561095e57600080fd5b5080359060208101359060408101359060600135600160a060020a03166119c6565b6103786004803603602081101561099657600080fd5b8101906020810181356401000000008111156109b157600080fd5b8201836020820111156109c357600080fd5b803590602001918460018302840111640100000000831117156109e557600080fd5b509092509050611a1d565b3480156109fc57600080fd5b50610a1a60048036036020811015610a1357600080fd5b5035611b43565b60405180826002811115610a2a57fe5b60ff16815260200191505060405180910390f35b348015610a4a57600080fd5b5061025860048036036020811015610a6157600080fd5b5035611bbb565b348015610a7457600080fd5b506105bc611c47565b348015610a8957600080fd5b5061037860048036036020811015610aa057600080fd5b810190602081018135640100000000811115610abb57600080fd5b820183602082011115610acd57600080fd5b80359060200191846001830284011164010000000083111715610aef57600080fd5b509092509050610229565b348015610b0657600080fd5b506102e9611c56565b348015610b1b57600080fd5b50610b3960048036036020811015610b3257600080fd5b5035611c5c565b6040518084600260200280838360005b83811015610b61578181015183820152602001610b49565b5050505090500183600260200280838360005b83811015610b8c578181015183820152602001610b74565b5050505090500182600260200280838360005b83811015610bb7578181015183820152602001610b9f565b50505050905001935050505060405180910390f35b348015610bd857600080fd5b506105bc60048036036020811015610bef57600080fd5b5035611d3d565b348015610c0257600080fd5b5061037860048036036020811015610c1957600080fd5b5035611db5565b348015610c2c57600080fd5b50610c4a60048036036020811015610c4357600080fd5b5035611e89565b60405180826004811115610a2a57fe5b348015610c6657600080fd5b5061025860048036036020811015610c7d57600080fd5b5035611f01565b348015610c9057600080fd5b506102e960048036036020811015610ca757600080fd5b5035611f8d565b348015610cba57600080fd5b506105bc611fab565b348015610ccf57600080fd5b5061025860048036036020811015610ce657600080fd5b5035611fba565b61037860048036036060811015610d0357600080fd5b50803590600160a060020a036020820135169060400135612046565b348015610d2b57600080fd5b506102e960048036036020811015610d4257600080fd5b5035612238565b348015610d5557600080fd5b506103786004803603610100811015610d6d57600080fd5b50803590602081013590600160a060020a0360408201351690606081013590608081019060c0016122b0565b348015610da557600080fd5b506102e960048036036020811015610dbc57600080fd5b5035600160a060020a0316612391565b348015610dd857600080fd5b50610378600480360360e0811015610def57600080fd5b50803590600160a060020a036020820135169060408101359060608101359060808101359060a08101359060c001356123ac565b348015610e2f57600080fd5b506102e960048036036020811015610e4657600080fd5b5035612422565b610e55612a29565b610e5d612a29565b6000838152600660205260409081902081517fbcdf4ebb000000000000000000000000000000000000000000000000000000008152600481018290529151909173__LedgerChannel_________________________9163bcdf4ebb91602480820192608092909190829003018186803b158015610ed957600080fd5b505af4158015610eed573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052506080811015610f1257600080fd5b509250506040820190505b915091565b600081815260066020908152604080832081517f418ec101000000000000000000000000000000000000000000000000000000008152600481018290529151909273__LedgerChannel_________________________9263418ec1019260248083019392829003018186803b158015610f9a57600080fd5b505af4158015610fae573d6000803e3d6000fd5b505050506040513d6020811015610fc457600080fd5b50519392505050565b6007546000818152600660205260409020907f296143e7e25aa055fbb871702776a67da540876e2be721d5c38ba23c97c90d646110098361249a565b6040518082600260200280838360005b83811015611031578181015183820152602001611019565b5050505090500191505060405180910390a2505050565b60005b898110156111235760006006818d8d8581811061106457fe5b905060200201358152602001908152602001600020905060006110ab8b8b8581811061108c57fe5b90506020020135600160a060020a0316836124c290919063ffffffff16565b905060008260040182600281106110be57fe5b6008020160030190508989858181106110d357fe5b60200291909101358255508787858181106110ea57fe5b602002919091013560018301555085858581811061110457fe5b905060200201358160040181905550505050808060010191505061104b565b5061113060088b8b612a47565b5050505050505050505050565b60008181526006602052604090206001600382015460ff16600481111561116057fe5b146111b5576040805160e560020a62461bcd02815260206004820152601460248201527f4368616e6e656c20737461747573206572726f72000000000000000000000000604482015290519081900360640190fd5b6015810154600160a060020a0316611217576040805160e560020a62461bcd02815260206004820152601a60248201527f4e6f2070656e64696e6720776974686472617720696e74656e74000000000000604482015290519081900360640190fd5b611227813363ffffffff61255b16565b61127b576040805160e560020a62461bcd02815260206004820152601660248201527f6d73672e73656e646572206973206e6f74207065657200000000000000000000604482015290519081900360640190fd5b60158101805473ffffffffffffffffffffffffffffffffffffffff19169055600060168201819055601782018190556018820181905560405183917f9a8a5493b616f074b3f754b5fd66049c8e7980f01547289e5e31808485c6002c91a25050565b60055460ff165b90565b600081815260066020908152604080832081517f1fd4a9c2000000000000000000000000000000000000000000000000000000008152600481018290529151909273__LedgerChannel_________________________92631fd4a9c29260248083019392829003018186803b158015610f9a57600080fd5b60008181526006602052604080822081517fc2f8816b000000000000000000000000000000000000000000000000000000008152600481018290529151839283928392909173__LedgerChannel_________________________9163c2f8816b91602480820192608092909190829003018186803b1580156113e057600080fd5b505af41580156113f4573d6000803e3d6000fd5b505050506040513d608081101561140a57600080fd5b508051602082015160408301516060909301519199909850919650945092505050565b60009081526020819052604090205490565b600254600160a060020a031690565b60005b6008548110156115105760008060060160006008848154811061147057fe5b9060005260206000200154815260200190815260200160002090506008828154811061149857fe5b90600052602060002001547fd0793cc4198bf052a6d91a9a1273c4af39f02a91b0e19029477511c278c5b2716114cd8361249a565b6040518082600260200280838360005b838110156114f55781810151838201526020016114dd565b5050505090500191505060405180910390a250600101611451565b505050565b61151d612a29565b611525612a29565b6000838152600660205260409081902081517fc814d28e000000000000000000000000000000000000000000000000000000008152600481018290529151909173__LedgerChannel_________________________9163c814d28e91602480820192608092909190829003018186803b158015610ed957600080fd5b600081815260066020908152604080832081517fd6b89e3a000000000000000000000000000000000000000000000000000000008152600481018290529151909273__LedgerChannel_________________________9263d6b89e3a9260248083019392829003018186803b158015610f9a57600080fd5b60008181526006602052604080822081517fc46dd9dd000000000000000000000000000000000000000000000000000000008152600481018290529151839283928392909173__LedgerChannel_________________________9163c46dd9dd91602480820192608092909190829003018186803b1580156113e057600080fd5b600081815260066020526040812060158101805460168301805460188501805473ffffffffffffffffffffffffffffffffffffffff19851690955591869055601785018690559490559192600160a060020a03909216919061170384848463ffffffff61259216565b61170b612a29565b611713612a29565b8573__LedgerChannel_________________________63c8ed149e90916040518263ffffffff1660e060020a0281526004018082815260200191505060c06040518083038186803b15801561176757600080fd5b505af415801561177b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525060c08110156117a057600080fd5b50604080518681528183019450608090920192508491600160a060020a038816918a917fe8110b4ee08638c48f6a4d5f726927df4e541893efa9d2c2c47a6b889041826e91899188918891906020820190849080838360005b838110156118115781810151838201526020016117f9565b5050505090500182600260200280838360005b8381101561183c578181015183820152602001611824565b50505050905001935050505060405180910390a450505050505050565b611861612a29565b611869612a29565b611871612a29565b611879612a29565b611881612a29565b611889612a29565b6000878152600660205260409081902081517fb3253127000000000000000000000000000000000000000000000000000000008152600481018290529151909173__LedgerChannel_________________________9163b32531279160248082019261018092909190829003018186803b15801561190657600080fd5b505af415801561191a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525061018081101561194057600080fd5b509860408a01985060808a01975060c08a0196506101008a0195506101408a01945092505050565b6000838152600660209081526040918290206015810154835186815293519193600160a060020a039091169287927f97883669625c4ff7f5432b4ca33fe75fb5fee985deb196a967e5758f846170fe9281900390910190a350505050565b600084815260066020526040902060158101805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0393909316929092179091556016810192909255436017830155601890910155600755565b6007546000908152600660205260409020611a36612a29565b50604080518082019091526004820154600160a060020a039081168252600c830154166020820152611a66612a29565b506040805180820190915260058301548152600d8301546020820152600280840154600754600160a060020a036101008304169290917f9d9f66221370175606b4085f28a419b201c9b6dafd9e0c4520e5bf69ea3e166d9160ff90911690811115611acd57fe5b85856040518084815260200183600260200280838360005b83811015611afd578181015183820152602001611ae5565b5050505090500182600260200280838360005b83811015611b28578181015183820152602001611b10565b50505050905001935050505060405180910390a35050505050565b600081815260066020908152604080832081517f12bb8c81000000000000000000000000000000000000000000000000000000008152600481018290529151909273__LedgerChannel_________________________926312bb8c819260248083019392829003018186803b158015610f9a57600080fd5b611bc3612a29565b611bcb612a29565b6000838152600660205260409081902081517f96a3c57f000000000000000000000000000000000000000000000000000000008152600481018290529151909173__LedgerChannel_________________________916396a3c57f91602480820192608092909190829003018186803b158015610ed957600080fd5b600354600160a060020a031690565b60075481565b611c64612a29565b611c6c612a29565b611c74612a29565b6000848152600660205260409081902081517fc8ed149e000000000000000000000000000000000000000000000000000000008152600481018290529151909173__LedgerChannel_________________________9163c8ed149e9160248082019260c092909190829003018186803b158015611cf057600080fd5b505af4158015611d04573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525060c0811015611d2957600080fd5b509560408701955060808701945092505050565b600081815260066020908152604080832081517f8970f8a5000000000000000000000000000000000000000000000000000000008152600481018290529151909273__LedgerChannel_________________________92638970f8a59260248083019392829003018186803b158015610f9a57600080fd5b600081815260066020526040812090611dcc612a29565b611dd5836125ff565b9150915081611e1a57611de7836127f0565b60405184907fa6549eb18490d42e7ec93f42115d1ee11b706d04077be9597034dd73ec8bcb3690600090a2505050611e86565b611e2583600361287c565b837f728ddd8c5acda5947c34db8d759c66ae70884f526ff9b93637d351b012ef3206826040518082600260200280838360005b83811015611e70578181015183820152602001611e58565b5050505090500191505060405180910390a25050505b50565b600081815260066020908152604080832081517f565aebdb000000000000000000000000000000000000000000000000000000008152600481018290529151909273__LedgerChannel_________________________9263565aebdb9260248083019392829003018186803b158015610f9a57600080fd5b611f09612a29565b611f11612a29565b6000838152600660205260409081902081517fd7db65ce000000000000000000000000000000000000000000000000000000008152600481018290529151909173__LedgerChannel_________________________9163d7db65ce91602480820192608092909190829003018186803b158015610ed957600080fd5b60088181548110611f9a57fe5b600091825260209091200154905081565b600154600160a060020a031690565b611fc2612a29565b611fca612a29565b6000838152600660205260409081902081517fc2c3f21f000000000000000000000000000000000000000000000000000000008152600481018290529151909173__LedgerChannel_________________________9163c2c3f21f91602480820192608092909190829003018186803b158015610ed957600080fd5b600083815260066020526040812090612065828563ffffffff6124c216565b90506000612079843463ffffffff61299c16565b90506120a48184600401846002811061208e57fe5b600802016001015461299c90919063ffffffff16565b8360040183600281106120b357fe5b60080201600101819055506120c6612a29565b6120ce612a29565b6120d6612a29565b8573__LedgerChannel_________________________63c8ed149e90916040518263ffffffff1660e060020a0281526004018082815260200191505060c06040518083038186803b15801561212a57600080fd5b505af415801561213e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525060c081101561216357600080fd5b506040805191945080850193506080850192508a917fb63f5dc096f516663ffb5ef2b611f0e2acca8617a868c2a3653cba5e3ed0e92c91869186918691908190859080838360005b838110156121c35781810151838201526020016121ab565b5050505090500183600260200280838360005b838110156121ee5781810151838201526020016121d6565b5050505090500182600260200280838360005b83811015612219578181015183820152602001612201565b50505050905001935050505060405180910390a2505050505050505050565b600081815260066020908152604080832081517fb80ddf7e000000000000000000000000000000000000000000000000000000008152600481018290529151909273__LedgerChannel_________________________9263b80ddf7e9260248083019392829003018186803b158015610f9a57600080fd5b6007869055600086815260066020526040902060018082018790556122d690829061287c565b6002818101805474ffffffffffffffffffffffffffffffffffffffff001916610100600160a060020a03891602179055849081111561231157fe5b60028083018054909160ff1990911690600190849081111561232f57fe5b0217905550600481018054600160a060020a038535811673ffffffffffffffffffffffffffffffffffffffff199283161790925583356005840155600c83018054909116602095860135909216919091179055910135600d9091015550505050565b600160a060020a031660009081526004602052604090205490565b6000878152600660205260408120906123cb828963ffffffff6124c216565b905060008260040182600281106123de57fe5b6008020160038101898155600482018990556005820188905560068201879055600790910185905590506124118a6129ae565b505050600796909655505050505050565b600081815260066020908152604080832081517f77ffc623000000000000000000000000000000000000000000000000000000008152600481018290529151909273__LedgerChannel_________________________926377ffc6239260248083019392829003018186803b158015610f9a57600080fd5b6124a2612a29565b506040805180820190915260078201548152600f90910154602082015290565b6004820154600090600160a060020a03838116911614156124e557506000612555565b600c830154600160a060020a038381169116141561250557506001612555565b6040805160e560020a62461bcd02815260206004820152600d60248201527f4e6f6e6578697374207065657200000000000000000000000000000000000000604482015290519081900360640190fd5b92915050565b6004820154600090600160a060020a038381169116148061258b5750600c830154600160a060020a038381169116145b9392505050565b600061259e84846124c2565b90506125c9828560040183600281106125b357fe5b600802016002015461299c90919063ffffffff16565b8460040182600281106125d857fe5b600802016002018190555060006125ee856129df565b10156125f957600080fd5b50505050565b6000612609612a29565b612611612a92565b604080518082019091526004850160026000835b828210156126b55760408051608080820183526008850287018054600160a060020a03168352600180820154602080860191909152600283015485870152855160a081018752600384015481526004840154818301526005840154968101969096526006830154606087810191909152600790930154938601939093529083019390935290835292019101612625565b5050505090506126c3612a29565b6040805180820190915260208084015160600151015181906126fa908560005b60200201516020015161299c90919063ffffffff16565b8152835160600151602090810151910190612717908560016126e3565b9052905060005b60028110156127e357600061276884836002811061273857fe5b60200201516040015185846002811061274d57fe5b6020020151606001516020015161299c90919063ffffffff16565b90508083836002811061277757fe5b602002015110156127a857600060405180604001604052806000815260200160008152509550955050505050610f1d565b6127c9818484600281106127b857fe5b60200201519063ffffffff612a1416565b8383600281106127d557fe5b60200201525060010161271e565b5060019350915050915091565b600081556127ff81600161287c565b6000600782018190556008820181905560098201819055600a8201819055600b8201819055600f82018190556010820181905560118201819055601282018190556013820181905560158201805473ffffffffffffffffffffffffffffffffffffffff191690556016820181905560178201819055601890910155565b80600481111561288857fe5b600383015460ff16600481111561289b57fe5b14156128a657612998565b6000600383015460ff1660048111156128bb57fe5b146129265760038201546128fc90600190600090819060ff1660048111156128df57fe5b815260200190815260200160002054612a1490919063ffffffff16565b6003830154600090819060ff16600481111561291457fe5b81526020810191909152604001600020555b612957600160008084600481111561293a57fe5b81526020019081526020016000205461299c90919063ffffffff16565b60008083600481111561296657fe5b815260208101919091526040016000205560038201805482919060ff1916600183600481111561299257fe5b02179055505b5050565b60008282018381101561258b57600080fd5b600081815260066020526040902060018101546129d290439063ffffffff61299c16565b815561299881600261287c565b600e8101546006820154600d830154600092839261258b92612a0891908290600489018761208e565b9063ffffffff612a1416565b600082821115612a2357600080fd5b50900390565b60405180604001604052806002906020820280388339509192915050565b828054828255906000526020600020908101928215612a82579160200282015b82811115612a82578235825591602001919060010190612a67565b50612a8e929150612ac0565b5090565b6040518061020001604052806002905b612aaa612ada565b815260200190600190039081612aa25790505090565b6112e491905b80821115612a8e5760008155600101612ac6565b6040518061010001604052806000600160a060020a031681526020016000815260200160008152602001612b0c612b11565b905290565b6040518060a001604052806000815260200160008152602001600080191681526020016000815260200160008152509056fea265627a7a723058205dbfea5eff255b38f2016866c8e3deccfdf5b77e5caf5d4c64f6069615f1726c64736f6c634300050a0032`

// DeployCelerLedger deploys a new Ethereum contract, binding an instance of CelerLedger to it.
func DeployCelerLedger(auth *bind.TransactOpts, backend bind.ContractBackend, _ethPool common.Address, _payRegistry common.Address, _celerWallet common.Address) (common.Address, *types.Transaction, *CelerLedger, error) {
	parsed, err := abi.JSON(strings.NewReader(CelerLedgerABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(CelerLedgerBin), backend, _ethPool, _payRegistry, _celerWallet)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &CelerLedger{CelerLedgerCaller: CelerLedgerCaller{contract: contract}, CelerLedgerTransactor: CelerLedgerTransactor{contract: contract}, CelerLedgerFilterer: CelerLedgerFilterer{contract: contract}}, nil
}

// CelerLedger is an auto generated Go binding around an Ethereum contract.
type CelerLedger struct {
	CelerLedgerCaller     // Read-only binding to the contract
	CelerLedgerTransactor // Write-only binding to the contract
	CelerLedgerFilterer   // Log filterer for contract events
}

// CelerLedgerCaller is an auto generated read-only Go binding around an Ethereum contract.
type CelerLedgerCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CelerLedgerTransactor is an auto generated write-only Go binding around an Ethereum contract.
type CelerLedgerTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CelerLedgerFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type CelerLedgerFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CelerLedgerSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type CelerLedgerSession struct {
	Contract     *CelerLedger      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// CelerLedgerCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type CelerLedgerCallerSession struct {
	Contract *CelerLedgerCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// CelerLedgerTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type CelerLedgerTransactorSession struct {
	Contract     *CelerLedgerTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// CelerLedgerRaw is an auto generated low-level Go binding around an Ethereum contract.
type CelerLedgerRaw struct {
	Contract *CelerLedger // Generic contract binding to access the raw methods on
}

// CelerLedgerCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type CelerLedgerCallerRaw struct {
	Contract *CelerLedgerCaller // Generic read-only contract binding to access the raw methods on
}

// CelerLedgerTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type CelerLedgerTransactorRaw struct {
	Contract *CelerLedgerTransactor // Generic write-only contract binding to access the raw methods on
}

// NewCelerLedger creates a new instance of CelerLedger, bound to a specific deployed contract.
func NewCelerLedger(address common.Address, backend bind.ContractBackend) (*CelerLedger, error) {
	contract, err := bindCelerLedger(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &CelerLedger{CelerLedgerCaller: CelerLedgerCaller{contract: contract}, CelerLedgerTransactor: CelerLedgerTransactor{contract: contract}, CelerLedgerFilterer: CelerLedgerFilterer{contract: contract}}, nil
}

// NewCelerLedgerCaller creates a new read-only instance of CelerLedger, bound to a specific deployed contract.
func NewCelerLedgerCaller(address common.Address, caller bind.ContractCaller) (*CelerLedgerCaller, error) {
	contract, err := bindCelerLedger(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &CelerLedgerCaller{contract: contract}, nil
}

// NewCelerLedgerTransactor creates a new write-only instance of CelerLedger, bound to a specific deployed contract.
func NewCelerLedgerTransactor(address common.Address, transactor bind.ContractTransactor) (*CelerLedgerTransactor, error) {
	contract, err := bindCelerLedger(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &CelerLedgerTransactor{contract: contract}, nil
}

// NewCelerLedgerFilterer creates a new log filterer instance of CelerLedger, bound to a specific deployed contract.
func NewCelerLedgerFilterer(address common.Address, filterer bind.ContractFilterer) (*CelerLedgerFilterer, error) {
	contract, err := bindCelerLedger(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &CelerLedgerFilterer{contract: contract}, nil
}

// bindCelerLedger binds a generic wrapper to an already deployed contract.
func bindCelerLedger(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(CelerLedgerABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CelerLedger *CelerLedgerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _CelerLedger.Contract.CelerLedgerCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CelerLedger *CelerLedgerRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CelerLedger.Contract.CelerLedgerTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CelerLedger *CelerLedgerRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CelerLedger.Contract.CelerLedgerTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CelerLedger *CelerLedgerCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _CelerLedger.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CelerLedger *CelerLedgerTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CelerLedger.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CelerLedger *CelerLedgerTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CelerLedger.Contract.contract.Transact(opts, method, params...)
}

// GetBalanceLimit is a free data retrieval call binding the contract method 0xec7c637d.
//
// Solidity: function getBalanceLimit(address _tokenAddr) constant returns(uint256)
func (_CelerLedger *CelerLedgerCaller) GetBalanceLimit(opts *bind.CallOpts, _tokenAddr common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _CelerLedger.contract.Call(opts, out, "getBalanceLimit", _tokenAddr)
	return *ret0, err
}

// GetBalanceLimit is a free data retrieval call binding the contract method 0xec7c637d.
//
// Solidity: function getBalanceLimit(address _tokenAddr) constant returns(uint256)
func (_CelerLedger *CelerLedgerSession) GetBalanceLimit(_tokenAddr common.Address) (*big.Int, error) {
	return _CelerLedger.Contract.GetBalanceLimit(&_CelerLedger.CallOpts, _tokenAddr)
}

// GetBalanceLimit is a free data retrieval call binding the contract method 0xec7c637d.
//
// Solidity: function getBalanceLimit(address _tokenAddr) constant returns(uint256)
func (_CelerLedger *CelerLedgerCallerSession) GetBalanceLimit(_tokenAddr common.Address) (*big.Int, error) {
	return _CelerLedger.Contract.GetBalanceLimit(&_CelerLedger.CallOpts, _tokenAddr)
}

// GetBalanceLimitsEnabled is a free data retrieval call binding the contract method 0x2b559ecc.
//
// Solidity: function getBalanceLimitsEnabled() constant returns(bool)
func (_CelerLedger *CelerLedgerCaller) GetBalanceLimitsEnabled(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _CelerLedger.contract.Call(opts, out, "getBalanceLimitsEnabled")
	return *ret0, err
}

// GetBalanceLimitsEnabled is a free data retrieval call binding the contract method 0x2b559ecc.
//
// Solidity: function getBalanceLimitsEnabled() constant returns(bool)
func (_CelerLedger *CelerLedgerSession) GetBalanceLimitsEnabled() (bool, error) {
	return _CelerLedger.Contract.GetBalanceLimitsEnabled(&_CelerLedger.CallOpts)
}

// GetBalanceLimitsEnabled is a free data retrieval call binding the contract method 0x2b559ecc.
//
// Solidity: function getBalanceLimitsEnabled() constant returns(bool)
func (_CelerLedger *CelerLedgerCallerSession) GetBalanceLimitsEnabled() (bool, error) {
	return _CelerLedger.Contract.GetBalanceLimitsEnabled(&_CelerLedger.CallOpts)
}

// GetBalanceMap is a free data retrieval call binding the contract method 0xbd480cb7.
//
// Solidity: function getBalanceMap(bytes32 _channelId) constant returns(address[2], uint256[2], uint256[2])
func (_CelerLedger *CelerLedgerCaller) GetBalanceMap(opts *bind.CallOpts, _channelId [32]byte) ([2]common.Address, [2]*big.Int, [2]*big.Int, error) {
	var (
		ret0 = new([2]common.Address)
		ret1 = new([2]*big.Int)
		ret2 = new([2]*big.Int)
	)
	out := &[]interface{}{
		ret0,
		ret1,
		ret2,
	}
	err := _CelerLedger.contract.Call(opts, out, "getBalanceMap", _channelId)
	return *ret0, *ret1, *ret2, err
}

// GetBalanceMap is a free data retrieval call binding the contract method 0xbd480cb7.
//
// Solidity: function getBalanceMap(bytes32 _channelId) constant returns(address[2], uint256[2], uint256[2])
func (_CelerLedger *CelerLedgerSession) GetBalanceMap(_channelId [32]byte) ([2]common.Address, [2]*big.Int, [2]*big.Int, error) {
	return _CelerLedger.Contract.GetBalanceMap(&_CelerLedger.CallOpts, _channelId)
}

// GetBalanceMap is a free data retrieval call binding the contract method 0xbd480cb7.
//
// Solidity: function getBalanceMap(bytes32 _channelId) constant returns(address[2], uint256[2], uint256[2])
func (_CelerLedger *CelerLedgerCallerSession) GetBalanceMap(_channelId [32]byte) ([2]common.Address, [2]*big.Int, [2]*big.Int, error) {
	return _CelerLedger.Contract.GetBalanceMap(&_CelerLedger.CallOpts, _channelId)
}

// GetCelerWallet is a free data retrieval call binding the contract method 0xa099a39f.
//
// Solidity: function getCelerWallet() constant returns(address)
func (_CelerLedger *CelerLedgerCaller) GetCelerWallet(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _CelerLedger.contract.Call(opts, out, "getCelerWallet")
	return *ret0, err
}

// GetCelerWallet is a free data retrieval call binding the contract method 0xa099a39f.
//
// Solidity: function getCelerWallet() constant returns(address)
func (_CelerLedger *CelerLedgerSession) GetCelerWallet() (common.Address, error) {
	return _CelerLedger.Contract.GetCelerWallet(&_CelerLedger.CallOpts)
}

// GetCelerWallet is a free data retrieval call binding the contract method 0xa099a39f.
//
// Solidity: function getCelerWallet() constant returns(address)
func (_CelerLedger *CelerLedgerCallerSession) GetCelerWallet() (common.Address, error) {
	return _CelerLedger.Contract.GetCelerWallet(&_CelerLedger.CallOpts)
}

// GetChannelMigrationArgs is a free data retrieval call binding the contract method 0x2f0ac304.
//
// Solidity: function getChannelMigrationArgs(bytes32 _channelId) constant returns(uint256, uint256, address, uint256)
func (_CelerLedger *CelerLedgerCaller) GetChannelMigrationArgs(opts *bind.CallOpts, _channelId [32]byte) (*big.Int, *big.Int, common.Address, *big.Int, error) {
	var (
		ret0 = new(*big.Int)
		ret1 = new(*big.Int)
		ret2 = new(common.Address)
		ret3 = new(*big.Int)
	)
	out := &[]interface{}{
		ret0,
		ret1,
		ret2,
		ret3,
	}
	err := _CelerLedger.contract.Call(opts, out, "getChannelMigrationArgs", _channelId)
	return *ret0, *ret1, *ret2, *ret3, err
}

// GetChannelMigrationArgs is a free data retrieval call binding the contract method 0x2f0ac304.
//
// Solidity: function getChannelMigrationArgs(bytes32 _channelId) constant returns(uint256, uint256, address, uint256)
func (_CelerLedger *CelerLedgerSession) GetChannelMigrationArgs(_channelId [32]byte) (*big.Int, *big.Int, common.Address, *big.Int, error) {
	return _CelerLedger.Contract.GetChannelMigrationArgs(&_CelerLedger.CallOpts, _channelId)
}

// GetChannelMigrationArgs is a free data retrieval call binding the contract method 0x2f0ac304.
//
// Solidity: function getChannelMigrationArgs(bytes32 _channelId) constant returns(uint256, uint256, address, uint256)
func (_CelerLedger *CelerLedgerCallerSession) GetChannelMigrationArgs(_channelId [32]byte) (*big.Int, *big.Int, common.Address, *big.Int, error) {
	return _CelerLedger.Contract.GetChannelMigrationArgs(&_CelerLedger.CallOpts, _channelId)
}

// GetChannelStatus is a free data retrieval call binding the contract method 0xcc0b94b7.
//
// Solidity: function getChannelStatus(bytes32 _channelId) constant returns(uint8)
func (_CelerLedger *CelerLedgerCaller) GetChannelStatus(opts *bind.CallOpts, _channelId [32]byte) (uint8, error) {
	var (
		ret0 = new(uint8)
	)
	out := ret0
	err := _CelerLedger.contract.Call(opts, out, "getChannelStatus", _channelId)
	return *ret0, err
}

// GetChannelStatus is a free data retrieval call binding the contract method 0xcc0b94b7.
//
// Solidity: function getChannelStatus(bytes32 _channelId) constant returns(uint8)
func (_CelerLedger *CelerLedgerSession) GetChannelStatus(_channelId [32]byte) (uint8, error) {
	return _CelerLedger.Contract.GetChannelStatus(&_CelerLedger.CallOpts, _channelId)
}

// GetChannelStatus is a free data retrieval call binding the contract method 0xcc0b94b7.
//
// Solidity: function getChannelStatus(bytes32 _channelId) constant returns(uint8)
func (_CelerLedger *CelerLedgerCallerSession) GetChannelStatus(_channelId [32]byte) (uint8, error) {
	return _CelerLedger.Contract.GetChannelStatus(&_CelerLedger.CallOpts, _channelId)
}

// GetChannelStatusNum is a free data retrieval call binding the contract method 0x307d6f96.
//
// Solidity: function getChannelStatusNum(uint256 _channelStatus) constant returns(uint256)
func (_CelerLedger *CelerLedgerCaller) GetChannelStatusNum(opts *bind.CallOpts, _channelStatus *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _CelerLedger.contract.Call(opts, out, "getChannelStatusNum", _channelStatus)
	return *ret0, err
}

// GetChannelStatusNum is a free data retrieval call binding the contract method 0x307d6f96.
//
// Solidity: function getChannelStatusNum(uint256 _channelStatus) constant returns(uint256)
func (_CelerLedger *CelerLedgerSession) GetChannelStatusNum(_channelStatus *big.Int) (*big.Int, error) {
	return _CelerLedger.Contract.GetChannelStatusNum(&_CelerLedger.CallOpts, _channelStatus)
}

// GetChannelStatusNum is a free data retrieval call binding the contract method 0x307d6f96.
//
// Solidity: function getChannelStatusNum(uint256 _channelStatus) constant returns(uint256)
func (_CelerLedger *CelerLedgerCallerSession) GetChannelStatusNum(_channelStatus *big.Int) (*big.Int, error) {
	return _CelerLedger.Contract.GetChannelStatusNum(&_CelerLedger.CallOpts, _channelStatus)
}

// GetCooperativeWithdrawSeqNum is a free data retrieval call binding the contract method 0xf0c73d70.
//
// Solidity: function getCooperativeWithdrawSeqNum(bytes32 _channelId) constant returns(uint256)
func (_CelerLedger *CelerLedgerCaller) GetCooperativeWithdrawSeqNum(opts *bind.CallOpts, _channelId [32]byte) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _CelerLedger.contract.Call(opts, out, "getCooperativeWithdrawSeqNum", _channelId)
	return *ret0, err
}

// GetCooperativeWithdrawSeqNum is a free data retrieval call binding the contract method 0xf0c73d70.
//
// Solidity: function getCooperativeWithdrawSeqNum(bytes32 _channelId) constant returns(uint256)
func (_CelerLedger *CelerLedgerSession) GetCooperativeWithdrawSeqNum(_channelId [32]byte) (*big.Int, error) {
	return _CelerLedger.Contract.GetCooperativeWithdrawSeqNum(&_CelerLedger.CallOpts, _channelId)
}

// GetCooperativeWithdrawSeqNum is a free data retrieval call binding the contract method 0xf0c73d70.
//
// Solidity: function getCooperativeWithdrawSeqNum(bytes32 _channelId) constant returns(uint256)
func (_CelerLedger *CelerLedgerCallerSession) GetCooperativeWithdrawSeqNum(_channelId [32]byte) (*big.Int, error) {
	return _CelerLedger.Contract.GetCooperativeWithdrawSeqNum(&_CelerLedger.CallOpts, _channelId)
}

// GetDisputeTimeout is a free data retrieval call binding the contract method 0xe6322df7.
//
// Solidity: function getDisputeTimeout(bytes32 _channelId) constant returns(uint256)
func (_CelerLedger *CelerLedgerCaller) GetDisputeTimeout(opts *bind.CallOpts, _channelId [32]byte) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _CelerLedger.contract.Call(opts, out, "getDisputeTimeout", _channelId)
	return *ret0, err
}

// GetDisputeTimeout is a free data retrieval call binding the contract method 0xe6322df7.
//
// Solidity: function getDisputeTimeout(bytes32 _channelId) constant returns(uint256)
func (_CelerLedger *CelerLedgerSession) GetDisputeTimeout(_channelId [32]byte) (*big.Int, error) {
	return _CelerLedger.Contract.GetDisputeTimeout(&_CelerLedger.CallOpts, _channelId)
}

// GetDisputeTimeout is a free data retrieval call binding the contract method 0xe6322df7.
//
// Solidity: function getDisputeTimeout(bytes32 _channelId) constant returns(uint256)
func (_CelerLedger *CelerLedgerCallerSession) GetDisputeTimeout(_channelId [32]byte) (*big.Int, error) {
	return _CelerLedger.Contract.GetDisputeTimeout(&_CelerLedger.CallOpts, _channelId)
}

// GetEthPool is a free data retrieval call binding the contract method 0xd75f960e.
//
// Solidity: function getEthPool() constant returns(address)
func (_CelerLedger *CelerLedgerCaller) GetEthPool(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _CelerLedger.contract.Call(opts, out, "getEthPool")
	return *ret0, err
}

// GetEthPool is a free data retrieval call binding the contract method 0xd75f960e.
//
// Solidity: function getEthPool() constant returns(address)
func (_CelerLedger *CelerLedgerSession) GetEthPool() (common.Address, error) {
	return _CelerLedger.Contract.GetEthPool(&_CelerLedger.CallOpts)
}

// GetEthPool is a free data retrieval call binding the contract method 0xd75f960e.
//
// Solidity: function getEthPool() constant returns(address)
func (_CelerLedger *CelerLedgerCallerSession) GetEthPool() (common.Address, error) {
	return _CelerLedger.Contract.GetEthPool(&_CelerLedger.CallOpts)
}

// GetLastPayResolveDeadlineMap is a free data retrieval call binding the contract method 0x9f1fad83.
//
// Solidity: function getLastPayResolveDeadlineMap(bytes32 _channelId) constant returns(address[2], uint256[2])
func (_CelerLedger *CelerLedgerCaller) GetLastPayResolveDeadlineMap(opts *bind.CallOpts, _channelId [32]byte) ([2]common.Address, [2]*big.Int, error) {
	var (
		ret0 = new([2]common.Address)
		ret1 = new([2]*big.Int)
	)
	out := &[]interface{}{
		ret0,
		ret1,
	}
	err := _CelerLedger.contract.Call(opts, out, "getLastPayResolveDeadlineMap", _channelId)
	return *ret0, *ret1, err
}

// GetLastPayResolveDeadlineMap is a free data retrieval call binding the contract method 0x9f1fad83.
//
// Solidity: function getLastPayResolveDeadlineMap(bytes32 _channelId) constant returns(address[2], uint256[2])
func (_CelerLedger *CelerLedgerSession) GetLastPayResolveDeadlineMap(_channelId [32]byte) ([2]common.Address, [2]*big.Int, error) {
	return _CelerLedger.Contract.GetLastPayResolveDeadlineMap(&_CelerLedger.CallOpts, _channelId)
}

// GetLastPayResolveDeadlineMap is a free data retrieval call binding the contract method 0x9f1fad83.
//
// Solidity: function getLastPayResolveDeadlineMap(bytes32 _channelId) constant returns(address[2], uint256[2])
func (_CelerLedger *CelerLedgerCallerSession) GetLastPayResolveDeadlineMap(_channelId [32]byte) ([2]common.Address, [2]*big.Int, error) {
	return _CelerLedger.Contract.GetLastPayResolveDeadlineMap(&_CelerLedger.CallOpts, _channelId)
}

// GetMigratedTo is a free data retrieval call binding the contract method 0xc38a325d.
//
// Solidity: function getMigratedTo(bytes32 _channelId) constant returns(address)
func (_CelerLedger *CelerLedgerCaller) GetMigratedTo(opts *bind.CallOpts, _channelId [32]byte) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _CelerLedger.contract.Call(opts, out, "getMigratedTo", _channelId)
	return *ret0, err
}

// GetMigratedTo is a free data retrieval call binding the contract method 0xc38a325d.
//
// Solidity: function getMigratedTo(bytes32 _channelId) constant returns(address)
func (_CelerLedger *CelerLedgerSession) GetMigratedTo(_channelId [32]byte) (common.Address, error) {
	return _CelerLedger.Contract.GetMigratedTo(&_CelerLedger.CallOpts, _channelId)
}

// GetMigratedTo is a free data retrieval call binding the contract method 0xc38a325d.
//
// Solidity: function getMigratedTo(bytes32 _channelId) constant returns(address)
func (_CelerLedger *CelerLedgerCallerSession) GetMigratedTo(_channelId [32]byte) (common.Address, error) {
	return _CelerLedger.Contract.GetMigratedTo(&_CelerLedger.CallOpts, _channelId)
}

// GetNextPayIdListHashMap is a free data retrieval call binding the contract method 0xcd3a1be6.
//
// Solidity: function getNextPayIdListHashMap(bytes32 _channelId) constant returns(address[2], bytes32[2])
func (_CelerLedger *CelerLedgerCaller) GetNextPayIdListHashMap(opts *bind.CallOpts, _channelId [32]byte) ([2]common.Address, [2][32]byte, error) {
	var (
		ret0 = new([2]common.Address)
		ret1 = new([2][32]byte)
	)
	out := &[]interface{}{
		ret0,
		ret1,
	}
	err := _CelerLedger.contract.Call(opts, out, "getNextPayIdListHashMap", _channelId)
	return *ret0, *ret1, err
}

// GetNextPayIdListHashMap is a free data retrieval call binding the contract method 0xcd3a1be6.
//
// Solidity: function getNextPayIdListHashMap(bytes32 _channelId) constant returns(address[2], bytes32[2])
func (_CelerLedger *CelerLedgerSession) GetNextPayIdListHashMap(_channelId [32]byte) ([2]common.Address, [2][32]byte, error) {
	return _CelerLedger.Contract.GetNextPayIdListHashMap(&_CelerLedger.CallOpts, _channelId)
}

// GetNextPayIdListHashMap is a free data retrieval call binding the contract method 0xcd3a1be6.
//
// Solidity: function getNextPayIdListHashMap(bytes32 _channelId) constant returns(address[2], bytes32[2])
func (_CelerLedger *CelerLedgerCallerSession) GetNextPayIdListHashMap(_channelId [32]byte) ([2]common.Address, [2][32]byte, error) {
	return _CelerLedger.Contract.GetNextPayIdListHashMap(&_CelerLedger.CallOpts, _channelId)
}

// GetPayRegistry is a free data retrieval call binding the contract method 0x312ea2c6.
//
// Solidity: function getPayRegistry() constant returns(address)
func (_CelerLedger *CelerLedgerCaller) GetPayRegistry(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _CelerLedger.contract.Call(opts, out, "getPayRegistry")
	return *ret0, err
}

// GetPayRegistry is a free data retrieval call binding the contract method 0x312ea2c6.
//
// Solidity: function getPayRegistry() constant returns(address)
func (_CelerLedger *CelerLedgerSession) GetPayRegistry() (common.Address, error) {
	return _CelerLedger.Contract.GetPayRegistry(&_CelerLedger.CallOpts)
}

// GetPayRegistry is a free data retrieval call binding the contract method 0x312ea2c6.
//
// Solidity: function getPayRegistry() constant returns(address)
func (_CelerLedger *CelerLedgerCallerSession) GetPayRegistry() (common.Address, error) {
	return _CelerLedger.Contract.GetPayRegistry(&_CelerLedger.CallOpts)
}

// GetPeersMigrationInfo is a free data retrieval call binding the contract method 0x88f41465.
//
// Solidity: function getPeersMigrationInfo(bytes32 _channelId) constant returns(address[2], uint256[2], uint256[2], uint256[2], uint256[2], uint256[2])
func (_CelerLedger *CelerLedgerCaller) GetPeersMigrationInfo(opts *bind.CallOpts, _channelId [32]byte) ([2]common.Address, [2]*big.Int, [2]*big.Int, [2]*big.Int, [2]*big.Int, [2]*big.Int, error) {
	var (
		ret0 = new([2]common.Address)
		ret1 = new([2]*big.Int)
		ret2 = new([2]*big.Int)
		ret3 = new([2]*big.Int)
		ret4 = new([2]*big.Int)
		ret5 = new([2]*big.Int)
	)
	out := &[]interface{}{
		ret0,
		ret1,
		ret2,
		ret3,
		ret4,
		ret5,
	}
	err := _CelerLedger.contract.Call(opts, out, "getPeersMigrationInfo", _channelId)
	return *ret0, *ret1, *ret2, *ret3, *ret4, *ret5, err
}

// GetPeersMigrationInfo is a free data retrieval call binding the contract method 0x88f41465.
//
// Solidity: function getPeersMigrationInfo(bytes32 _channelId) constant returns(address[2], uint256[2], uint256[2], uint256[2], uint256[2], uint256[2])
func (_CelerLedger *CelerLedgerSession) GetPeersMigrationInfo(_channelId [32]byte) ([2]common.Address, [2]*big.Int, [2]*big.Int, [2]*big.Int, [2]*big.Int, [2]*big.Int, error) {
	return _CelerLedger.Contract.GetPeersMigrationInfo(&_CelerLedger.CallOpts, _channelId)
}

// GetPeersMigrationInfo is a free data retrieval call binding the contract method 0x88f41465.
//
// Solidity: function getPeersMigrationInfo(bytes32 _channelId) constant returns(address[2], uint256[2], uint256[2], uint256[2], uint256[2], uint256[2])
func (_CelerLedger *CelerLedgerCallerSession) GetPeersMigrationInfo(_channelId [32]byte) ([2]common.Address, [2]*big.Int, [2]*big.Int, [2]*big.Int, [2]*big.Int, [2]*big.Int, error) {
	return _CelerLedger.Contract.GetPeersMigrationInfo(&_CelerLedger.CallOpts, _channelId)
}

// GetPendingPayOutMap is a free data retrieval call binding the contract method 0x0165cef8.
//
// Solidity: function getPendingPayOutMap(bytes32 _channelId) constant returns(address[2], uint256[2])
func (_CelerLedger *CelerLedgerCaller) GetPendingPayOutMap(opts *bind.CallOpts, _channelId [32]byte) ([2]common.Address, [2]*big.Int, error) {
	var (
		ret0 = new([2]common.Address)
		ret1 = new([2]*big.Int)
	)
	out := &[]interface{}{
		ret0,
		ret1,
	}
	err := _CelerLedger.contract.Call(opts, out, "getPendingPayOutMap", _channelId)
	return *ret0, *ret1, err
}

// GetPendingPayOutMap is a free data retrieval call binding the contract method 0x0165cef8.
//
// Solidity: function getPendingPayOutMap(bytes32 _channelId) constant returns(address[2], uint256[2])
func (_CelerLedger *CelerLedgerSession) GetPendingPayOutMap(_channelId [32]byte) ([2]common.Address, [2]*big.Int, error) {
	return _CelerLedger.Contract.GetPendingPayOutMap(&_CelerLedger.CallOpts, _channelId)
}

// GetPendingPayOutMap is a free data retrieval call binding the contract method 0x0165cef8.
//
// Solidity: function getPendingPayOutMap(bytes32 _channelId) constant returns(address[2], uint256[2])
func (_CelerLedger *CelerLedgerCallerSession) GetPendingPayOutMap(_channelId [32]byte) ([2]common.Address, [2]*big.Int, error) {
	return _CelerLedger.Contract.GetPendingPayOutMap(&_CelerLedger.CallOpts, _channelId)
}

// GetSettleFinalizedTime is a free data retrieval call binding the contract method 0x09b65d86.
//
// Solidity: function getSettleFinalizedTime(bytes32 _channelId) constant returns(uint256)
func (_CelerLedger *CelerLedgerCaller) GetSettleFinalizedTime(opts *bind.CallOpts, _channelId [32]byte) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _CelerLedger.contract.Call(opts, out, "getSettleFinalizedTime", _channelId)
	return *ret0, err
}

// GetSettleFinalizedTime is a free data retrieval call binding the contract method 0x09b65d86.
//
// Solidity: function getSettleFinalizedTime(bytes32 _channelId) constant returns(uint256)
func (_CelerLedger *CelerLedgerSession) GetSettleFinalizedTime(_channelId [32]byte) (*big.Int, error) {
	return _CelerLedger.Contract.GetSettleFinalizedTime(&_CelerLedger.CallOpts, _channelId)
}

// GetSettleFinalizedTime is a free data retrieval call binding the contract method 0x09b65d86.
//
// Solidity: function getSettleFinalizedTime(bytes32 _channelId) constant returns(uint256)
func (_CelerLedger *CelerLedgerCallerSession) GetSettleFinalizedTime(_channelId [32]byte) (*big.Int, error) {
	return _CelerLedger.Contract.GetSettleFinalizedTime(&_CelerLedger.CallOpts, _channelId)
}

// GetStateSeqNumMap is a free data retrieval call binding the contract method 0x666a6d65.
//
// Solidity: function getStateSeqNumMap(bytes32 _channelId) constant returns(address[2], uint256[2])
func (_CelerLedger *CelerLedgerCaller) GetStateSeqNumMap(opts *bind.CallOpts, _channelId [32]byte) ([2]common.Address, [2]*big.Int, error) {
	var (
		ret0 = new([2]common.Address)
		ret1 = new([2]*big.Int)
	)
	out := &[]interface{}{
		ret0,
		ret1,
	}
	err := _CelerLedger.contract.Call(opts, out, "getStateSeqNumMap", _channelId)
	return *ret0, *ret1, err
}

// GetStateSeqNumMap is a free data retrieval call binding the contract method 0x666a6d65.
//
// Solidity: function getStateSeqNumMap(bytes32 _channelId) constant returns(address[2], uint256[2])
func (_CelerLedger *CelerLedgerSession) GetStateSeqNumMap(_channelId [32]byte) ([2]common.Address, [2]*big.Int, error) {
	return _CelerLedger.Contract.GetStateSeqNumMap(&_CelerLedger.CallOpts, _channelId)
}

// GetStateSeqNumMap is a free data retrieval call binding the contract method 0x666a6d65.
//
// Solidity: function getStateSeqNumMap(bytes32 _channelId) constant returns(address[2], uint256[2])
func (_CelerLedger *CelerLedgerCallerSession) GetStateSeqNumMap(_channelId [32]byte) ([2]common.Address, [2]*big.Int, error) {
	return _CelerLedger.Contract.GetStateSeqNumMap(&_CelerLedger.CallOpts, _channelId)
}

// GetTokenContract is a free data retrieval call binding the contract method 0x2e2a5a02.
//
// Solidity: function getTokenContract(bytes32 _channelId) constant returns(address)
func (_CelerLedger *CelerLedgerCaller) GetTokenContract(opts *bind.CallOpts, _channelId [32]byte) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _CelerLedger.contract.Call(opts, out, "getTokenContract", _channelId)
	return *ret0, err
}

// GetTokenContract is a free data retrieval call binding the contract method 0x2e2a5a02.
//
// Solidity: function getTokenContract(bytes32 _channelId) constant returns(address)
func (_CelerLedger *CelerLedgerSession) GetTokenContract(_channelId [32]byte) (common.Address, error) {
	return _CelerLedger.Contract.GetTokenContract(&_CelerLedger.CallOpts, _channelId)
}

// GetTokenContract is a free data retrieval call binding the contract method 0x2e2a5a02.
//
// Solidity: function getTokenContract(bytes32 _channelId) constant returns(address)
func (_CelerLedger *CelerLedgerCallerSession) GetTokenContract(_channelId [32]byte) (common.Address, error) {
	return _CelerLedger.Contract.GetTokenContract(&_CelerLedger.CallOpts, _channelId)
}

// GetTokenType is a free data retrieval call binding the contract method 0x979a9b5e.
//
// Solidity: function getTokenType(bytes32 _channelId) constant returns(uint8)
func (_CelerLedger *CelerLedgerCaller) GetTokenType(opts *bind.CallOpts, _channelId [32]byte) (uint8, error) {
	var (
		ret0 = new(uint8)
	)
	out := ret0
	err := _CelerLedger.contract.Call(opts, out, "getTokenType", _channelId)
	return *ret0, err
}

// GetTokenType is a free data retrieval call binding the contract method 0x979a9b5e.
//
// Solidity: function getTokenType(bytes32 _channelId) constant returns(uint8)
func (_CelerLedger *CelerLedgerSession) GetTokenType(_channelId [32]byte) (uint8, error) {
	return _CelerLedger.Contract.GetTokenType(&_CelerLedger.CallOpts, _channelId)
}

// GetTokenType is a free data retrieval call binding the contract method 0x979a9b5e.
//
// Solidity: function getTokenType(bytes32 _channelId) constant returns(uint8)
func (_CelerLedger *CelerLedgerCallerSession) GetTokenType(_channelId [32]byte) (uint8, error) {
	return _CelerLedger.Contract.GetTokenType(&_CelerLedger.CallOpts, _channelId)
}

// GetTotalBalance is a free data retrieval call binding the contract method 0x69d5dd67.
//
// Solidity: function getTotalBalance(bytes32 _channelId) constant returns(uint256)
func (_CelerLedger *CelerLedgerCaller) GetTotalBalance(opts *bind.CallOpts, _channelId [32]byte) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _CelerLedger.contract.Call(opts, out, "getTotalBalance", _channelId)
	return *ret0, err
}

// GetTotalBalance is a free data retrieval call binding the contract method 0x69d5dd67.
//
// Solidity: function getTotalBalance(bytes32 _channelId) constant returns(uint256)
func (_CelerLedger *CelerLedgerSession) GetTotalBalance(_channelId [32]byte) (*big.Int, error) {
	return _CelerLedger.Contract.GetTotalBalance(&_CelerLedger.CallOpts, _channelId)
}

// GetTotalBalance is a free data retrieval call binding the contract method 0x69d5dd67.
//
// Solidity: function getTotalBalance(bytes32 _channelId) constant returns(uint256)
func (_CelerLedger *CelerLedgerCallerSession) GetTotalBalance(_channelId [32]byte) (*big.Int, error) {
	return _CelerLedger.Contract.GetTotalBalance(&_CelerLedger.CallOpts, _channelId)
}

// GetTransferOutMap is a free data retrieval call binding the contract method 0xd927bfc4.
//
// Solidity: function getTransferOutMap(bytes32 _channelId) constant returns(address[2], uint256[2])
func (_CelerLedger *CelerLedgerCaller) GetTransferOutMap(opts *bind.CallOpts, _channelId [32]byte) ([2]common.Address, [2]*big.Int, error) {
	var (
		ret0 = new([2]common.Address)
		ret1 = new([2]*big.Int)
	)
	out := &[]interface{}{
		ret0,
		ret1,
	}
	err := _CelerLedger.contract.Call(opts, out, "getTransferOutMap", _channelId)
	return *ret0, *ret1, err
}

// GetTransferOutMap is a free data retrieval call binding the contract method 0xd927bfc4.
//
// Solidity: function getTransferOutMap(bytes32 _channelId) constant returns(address[2], uint256[2])
func (_CelerLedger *CelerLedgerSession) GetTransferOutMap(_channelId [32]byte) ([2]common.Address, [2]*big.Int, error) {
	return _CelerLedger.Contract.GetTransferOutMap(&_CelerLedger.CallOpts, _channelId)
}

// GetTransferOutMap is a free data retrieval call binding the contract method 0xd927bfc4.
//
// Solidity: function getTransferOutMap(bytes32 _channelId) constant returns(address[2], uint256[2])
func (_CelerLedger *CelerLedgerCallerSession) GetTransferOutMap(_channelId [32]byte) ([2]common.Address, [2]*big.Int, error) {
	return _CelerLedger.Contract.GetTransferOutMap(&_CelerLedger.CallOpts, _channelId)
}

// GetWithdrawIntent is a free data retrieval call binding the contract method 0x76bff117.
//
// Solidity: function getWithdrawIntent(bytes32 _channelId) constant returns(address, uint256, uint256, bytes32)
func (_CelerLedger *CelerLedgerCaller) GetWithdrawIntent(opts *bind.CallOpts, _channelId [32]byte) (common.Address, *big.Int, *big.Int, [32]byte, error) {
	var (
		ret0 = new(common.Address)
		ret1 = new(*big.Int)
		ret2 = new(*big.Int)
		ret3 = new([32]byte)
	)
	out := &[]interface{}{
		ret0,
		ret1,
		ret2,
		ret3,
	}
	err := _CelerLedger.contract.Call(opts, out, "getWithdrawIntent", _channelId)
	return *ret0, *ret1, *ret2, *ret3, err
}

// GetWithdrawIntent is a free data retrieval call binding the contract method 0x76bff117.
//
// Solidity: function getWithdrawIntent(bytes32 _channelId) constant returns(address, uint256, uint256, bytes32)
func (_CelerLedger *CelerLedgerSession) GetWithdrawIntent(_channelId [32]byte) (common.Address, *big.Int, *big.Int, [32]byte, error) {
	return _CelerLedger.Contract.GetWithdrawIntent(&_CelerLedger.CallOpts, _channelId)
}

// GetWithdrawIntent is a free data retrieval call binding the contract method 0x76bff117.
//
// Solidity: function getWithdrawIntent(bytes32 _channelId) constant returns(address, uint256, uint256, bytes32)
func (_CelerLedger *CelerLedgerCallerSession) GetWithdrawIntent(_channelId [32]byte) (common.Address, *big.Int, *big.Int, [32]byte, error) {
	return _CelerLedger.Contract.GetWithdrawIntent(&_CelerLedger.CallOpts, _channelId)
}

// TmpChannelId is a free data retrieval call binding the contract method 0xb962a1d8.
//
// Solidity: function tmpChannelId() constant returns(bytes32)
func (_CelerLedger *CelerLedgerCaller) TmpChannelId(opts *bind.CallOpts) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _CelerLedger.contract.Call(opts, out, "tmpChannelId")
	return *ret0, err
}

// TmpChannelId is a free data retrieval call binding the contract method 0xb962a1d8.
//
// Solidity: function tmpChannelId() constant returns(bytes32)
func (_CelerLedger *CelerLedgerSession) TmpChannelId() ([32]byte, error) {
	return _CelerLedger.Contract.TmpChannelId(&_CelerLedger.CallOpts)
}

// TmpChannelId is a free data retrieval call binding the contract method 0xb962a1d8.
//
// Solidity: function tmpChannelId() constant returns(bytes32)
func (_CelerLedger *CelerLedgerCallerSession) TmpChannelId() ([32]byte, error) {
	return _CelerLedger.Contract.TmpChannelId(&_CelerLedger.CallOpts)
}

// TmpChannelIds is a free data retrieval call binding the contract method 0xd4e3680f.
//
// Solidity: function tmpChannelIds(uint256 ) constant returns(bytes32)
func (_CelerLedger *CelerLedgerCaller) TmpChannelIds(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _CelerLedger.contract.Call(opts, out, "tmpChannelIds", arg0)
	return *ret0, err
}

// TmpChannelIds is a free data retrieval call binding the contract method 0xd4e3680f.
//
// Solidity: function tmpChannelIds(uint256 ) constant returns(bytes32)
func (_CelerLedger *CelerLedgerSession) TmpChannelIds(arg0 *big.Int) ([32]byte, error) {
	return _CelerLedger.Contract.TmpChannelIds(&_CelerLedger.CallOpts, arg0)
}

// TmpChannelIds is a free data retrieval call binding the contract method 0xd4e3680f.
//
// Solidity: function tmpChannelIds(uint256 ) constant returns(bytes32)
func (_CelerLedger *CelerLedgerCallerSession) TmpChannelIds(arg0 *big.Int) ([32]byte, error) {
	return _CelerLedger.Contract.TmpChannelIds(&_CelerLedger.CallOpts, arg0)
}

// ConfirmSettle is a paid mutator transaction binding the contract method 0xc7ff8625.
//
// Solidity: function confirmSettle(bytes32 _channelId) returns()
func (_CelerLedger *CelerLedgerTransactor) ConfirmSettle(opts *bind.TransactOpts, _channelId [32]byte) (*types.Transaction, error) {
	return _CelerLedger.contract.Transact(opts, "confirmSettle", _channelId)
}

// ConfirmSettle is a paid mutator transaction binding the contract method 0xc7ff8625.
//
// Solidity: function confirmSettle(bytes32 _channelId) returns()
func (_CelerLedger *CelerLedgerSession) ConfirmSettle(_channelId [32]byte) (*types.Transaction, error) {
	return _CelerLedger.Contract.ConfirmSettle(&_CelerLedger.TransactOpts, _channelId)
}

// ConfirmSettle is a paid mutator transaction binding the contract method 0xc7ff8625.
//
// Solidity: function confirmSettle(bytes32 _channelId) returns()
func (_CelerLedger *CelerLedgerTransactorSession) ConfirmSettle(_channelId [32]byte) (*types.Transaction, error) {
	return _CelerLedger.Contract.ConfirmSettle(&_CelerLedger.TransactOpts, _channelId)
}

// ConfirmWithdraw is a paid mutator transaction binding the contract method 0x7e9a7a3e.
//
// Solidity: function confirmWithdraw(bytes32 _channelId) returns()
func (_CelerLedger *CelerLedgerTransactor) ConfirmWithdraw(opts *bind.TransactOpts, _channelId [32]byte) (*types.Transaction, error) {
	return _CelerLedger.contract.Transact(opts, "confirmWithdraw", _channelId)
}

// ConfirmWithdraw is a paid mutator transaction binding the contract method 0x7e9a7a3e.
//
// Solidity: function confirmWithdraw(bytes32 _channelId) returns()
func (_CelerLedger *CelerLedgerSession) ConfirmWithdraw(_channelId [32]byte) (*types.Transaction, error) {
	return _CelerLedger.Contract.ConfirmWithdraw(&_CelerLedger.TransactOpts, _channelId)
}

// ConfirmWithdraw is a paid mutator transaction binding the contract method 0x7e9a7a3e.
//
// Solidity: function confirmWithdraw(bytes32 _channelId) returns()
func (_CelerLedger *CelerLedgerTransactorSession) ConfirmWithdraw(_channelId [32]byte) (*types.Transaction, error) {
	return _CelerLedger.Contract.ConfirmWithdraw(&_CelerLedger.TransactOpts, _channelId)
}

// Deposit is a paid mutator transaction binding the contract method 0xd954863c.
//
// Solidity: function deposit(bytes32 _channelId, address _receiver, uint256 _transferFromAmount) returns()
func (_CelerLedger *CelerLedgerTransactor) Deposit(opts *bind.TransactOpts, _channelId [32]byte, _receiver common.Address, _transferFromAmount *big.Int) (*types.Transaction, error) {
	return _CelerLedger.contract.Transact(opts, "deposit", _channelId, _receiver, _transferFromAmount)
}

// Deposit is a paid mutator transaction binding the contract method 0xd954863c.
//
// Solidity: function deposit(bytes32 _channelId, address _receiver, uint256 _transferFromAmount) returns()
func (_CelerLedger *CelerLedgerSession) Deposit(_channelId [32]byte, _receiver common.Address, _transferFromAmount *big.Int) (*types.Transaction, error) {
	return _CelerLedger.Contract.Deposit(&_CelerLedger.TransactOpts, _channelId, _receiver, _transferFromAmount)
}

// Deposit is a paid mutator transaction binding the contract method 0xd954863c.
//
// Solidity: function deposit(bytes32 _channelId, address _receiver, uint256 _transferFromAmount) returns()
func (_CelerLedger *CelerLedgerTransactorSession) Deposit(_channelId [32]byte, _receiver common.Address, _transferFromAmount *big.Int) (*types.Transaction, error) {
	return _CelerLedger.Contract.Deposit(&_CelerLedger.TransactOpts, _channelId, _receiver, _transferFromAmount)
}

// IntendSettle is a paid mutator transaction binding the contract method 0x130d33fe.
//
// Solidity: function intendSettle(bytes _signedSimplexStateArray) returns()
func (_CelerLedger *CelerLedgerTransactor) IntendSettle(opts *bind.TransactOpts, _signedSimplexStateArray []byte) (*types.Transaction, error) {
	return _CelerLedger.contract.Transact(opts, "intendSettle", _signedSimplexStateArray)
}

// IntendSettle is a paid mutator transaction binding the contract method 0x130d33fe.
//
// Solidity: function intendSettle(bytes _signedSimplexStateArray) returns()
func (_CelerLedger *CelerLedgerSession) IntendSettle(_signedSimplexStateArray []byte) (*types.Transaction, error) {
	return _CelerLedger.Contract.IntendSettle(&_CelerLedger.TransactOpts, _signedSimplexStateArray)
}

// IntendSettle is a paid mutator transaction binding the contract method 0x130d33fe.
//
// Solidity: function intendSettle(bytes _signedSimplexStateArray) returns()
func (_CelerLedger *CelerLedgerTransactorSession) IntendSettle(_signedSimplexStateArray []byte) (*types.Transaction, error) {
	return _CelerLedger.Contract.IntendSettle(&_CelerLedger.TransactOpts, _signedSimplexStateArray)
}

// IntendSettleMockSet is a paid mutator transaction binding the contract method 0xeff3417c.
//
// Solidity: function intendSettleMockSet(bytes32 _channelId, address _peerFrom, uint256 _seqNum, uint256 _transferOut, bytes32 _nextPayIdListHash, uint256 _lastPayResolveDeadline, uint256 _pendingPayOut) returns()
func (_CelerLedger *CelerLedgerTransactor) IntendSettleMockSet(opts *bind.TransactOpts, _channelId [32]byte, _peerFrom common.Address, _seqNum *big.Int, _transferOut *big.Int, _nextPayIdListHash [32]byte, _lastPayResolveDeadline *big.Int, _pendingPayOut *big.Int) (*types.Transaction, error) {
	return _CelerLedger.contract.Transact(opts, "intendSettleMockSet", _channelId, _peerFrom, _seqNum, _transferOut, _nextPayIdListHash, _lastPayResolveDeadline, _pendingPayOut)
}

// IntendSettleMockSet is a paid mutator transaction binding the contract method 0xeff3417c.
//
// Solidity: function intendSettleMockSet(bytes32 _channelId, address _peerFrom, uint256 _seqNum, uint256 _transferOut, bytes32 _nextPayIdListHash, uint256 _lastPayResolveDeadline, uint256 _pendingPayOut) returns()
func (_CelerLedger *CelerLedgerSession) IntendSettleMockSet(_channelId [32]byte, _peerFrom common.Address, _seqNum *big.Int, _transferOut *big.Int, _nextPayIdListHash [32]byte, _lastPayResolveDeadline *big.Int, _pendingPayOut *big.Int) (*types.Transaction, error) {
	return _CelerLedger.Contract.IntendSettleMockSet(&_CelerLedger.TransactOpts, _channelId, _peerFrom, _seqNum, _transferOut, _nextPayIdListHash, _lastPayResolveDeadline, _pendingPayOut)
}

// IntendSettleMockSet is a paid mutator transaction binding the contract method 0xeff3417c.
//
// Solidity: function intendSettleMockSet(bytes32 _channelId, address _peerFrom, uint256 _seqNum, uint256 _transferOut, bytes32 _nextPayIdListHash, uint256 _lastPayResolveDeadline, uint256 _pendingPayOut) returns()
func (_CelerLedger *CelerLedgerTransactorSession) IntendSettleMockSet(_channelId [32]byte, _peerFrom common.Address, _seqNum *big.Int, _transferOut *big.Int, _nextPayIdListHash [32]byte, _lastPayResolveDeadline *big.Int, _pendingPayOut *big.Int) (*types.Transaction, error) {
	return _CelerLedger.Contract.IntendSettleMockSet(&_CelerLedger.TransactOpts, _channelId, _peerFrom, _seqNum, _transferOut, _nextPayIdListHash, _lastPayResolveDeadline, _pendingPayOut)
}

// IntendSettleRevert is a paid mutator transaction binding the contract method 0xa979e229.
//
// Solidity: function intendSettleRevert(bytes _signedSimplexStateArray) returns()
func (_CelerLedger *CelerLedgerTransactor) IntendSettleRevert(opts *bind.TransactOpts, _signedSimplexStateArray []byte) (*types.Transaction, error) {
	return _CelerLedger.contract.Transact(opts, "intendSettleRevert", _signedSimplexStateArray)
}

// IntendSettleRevert is a paid mutator transaction binding the contract method 0xa979e229.
//
// Solidity: function intendSettleRevert(bytes _signedSimplexStateArray) returns()
func (_CelerLedger *CelerLedgerSession) IntendSettleRevert(_signedSimplexStateArray []byte) (*types.Transaction, error) {
	return _CelerLedger.Contract.IntendSettleRevert(&_CelerLedger.TransactOpts, _signedSimplexStateArray)
}

// IntendSettleRevert is a paid mutator transaction binding the contract method 0xa979e229.
//
// Solidity: function intendSettleRevert(bytes _signedSimplexStateArray) returns()
func (_CelerLedger *CelerLedgerTransactorSession) IntendSettleRevert(_signedSimplexStateArray []byte) (*types.Transaction, error) {
	return _CelerLedger.Contract.IntendSettleRevert(&_CelerLedger.TransactOpts, _signedSimplexStateArray)
}

// IntendWithdraw is a paid mutator transaction binding the contract method 0x8942ecb2.
//
// Solidity: function intendWithdraw(bytes32 _channelId, uint256 _amount, bytes32 _recipientChannelId) returns()
func (_CelerLedger *CelerLedgerTransactor) IntendWithdraw(opts *bind.TransactOpts, _channelId [32]byte, _amount *big.Int, _recipientChannelId [32]byte) (*types.Transaction, error) {
	return _CelerLedger.contract.Transact(opts, "intendWithdraw", _channelId, _amount, _recipientChannelId)
}

// IntendWithdraw is a paid mutator transaction binding the contract method 0x8942ecb2.
//
// Solidity: function intendWithdraw(bytes32 _channelId, uint256 _amount, bytes32 _recipientChannelId) returns()
func (_CelerLedger *CelerLedgerSession) IntendWithdraw(_channelId [32]byte, _amount *big.Int, _recipientChannelId [32]byte) (*types.Transaction, error) {
	return _CelerLedger.Contract.IntendWithdraw(&_CelerLedger.TransactOpts, _channelId, _amount, _recipientChannelId)
}

// IntendWithdraw is a paid mutator transaction binding the contract method 0x8942ecb2.
//
// Solidity: function intendWithdraw(bytes32 _channelId, uint256 _amount, bytes32 _recipientChannelId) returns()
func (_CelerLedger *CelerLedgerTransactorSession) IntendWithdraw(_channelId [32]byte, _amount *big.Int, _recipientChannelId [32]byte) (*types.Transaction, error) {
	return _CelerLedger.Contract.IntendWithdraw(&_CelerLedger.TransactOpts, _channelId, _amount, _recipientChannelId)
}

// IntendWithdrawMockSet is a paid mutator transaction binding the contract method 0x8f16cef4.
//
// Solidity: function intendWithdrawMockSet(bytes32 _channelId, uint256 _amount, bytes32 _recipientChannelId, address _receiver) returns()
func (_CelerLedger *CelerLedgerTransactor) IntendWithdrawMockSet(opts *bind.TransactOpts, _channelId [32]byte, _amount *big.Int, _recipientChannelId [32]byte, _receiver common.Address) (*types.Transaction, error) {
	return _CelerLedger.contract.Transact(opts, "intendWithdrawMockSet", _channelId, _amount, _recipientChannelId, _receiver)
}

// IntendWithdrawMockSet is a paid mutator transaction binding the contract method 0x8f16cef4.
//
// Solidity: function intendWithdrawMockSet(bytes32 _channelId, uint256 _amount, bytes32 _recipientChannelId, address _receiver) returns()
func (_CelerLedger *CelerLedgerSession) IntendWithdrawMockSet(_channelId [32]byte, _amount *big.Int, _recipientChannelId [32]byte, _receiver common.Address) (*types.Transaction, error) {
	return _CelerLedger.Contract.IntendWithdrawMockSet(&_CelerLedger.TransactOpts, _channelId, _amount, _recipientChannelId, _receiver)
}

// IntendWithdrawMockSet is a paid mutator transaction binding the contract method 0x8f16cef4.
//
// Solidity: function intendWithdrawMockSet(bytes32 _channelId, uint256 _amount, bytes32 _recipientChannelId, address _receiver) returns()
func (_CelerLedger *CelerLedgerTransactorSession) IntendWithdrawMockSet(_channelId [32]byte, _amount *big.Int, _recipientChannelId [32]byte, _receiver common.Address) (*types.Transaction, error) {
	return _CelerLedger.Contract.IntendWithdrawMockSet(&_CelerLedger.TransactOpts, _channelId, _amount, _recipientChannelId, _receiver)
}

// OpenChannel is a paid mutator transaction binding the contract method 0x93b7b3ce.
//
// Solidity: function openChannel(bytes _openRequest) returns()
func (_CelerLedger *CelerLedgerTransactor) OpenChannel(opts *bind.TransactOpts, _openRequest []byte) (*types.Transaction, error) {
	return _CelerLedger.contract.Transact(opts, "openChannel", _openRequest)
}

// OpenChannel is a paid mutator transaction binding the contract method 0x93b7b3ce.
//
// Solidity: function openChannel(bytes _openRequest) returns()
func (_CelerLedger *CelerLedgerSession) OpenChannel(_openRequest []byte) (*types.Transaction, error) {
	return _CelerLedger.Contract.OpenChannel(&_CelerLedger.TransactOpts, _openRequest)
}

// OpenChannel is a paid mutator transaction binding the contract method 0x93b7b3ce.
//
// Solidity: function openChannel(bytes _openRequest) returns()
func (_CelerLedger *CelerLedgerTransactorSession) OpenChannel(_openRequest []byte) (*types.Transaction, error) {
	return _CelerLedger.Contract.OpenChannel(&_CelerLedger.TransactOpts, _openRequest)
}

// OpenChannelMockSet is a paid mutator transaction binding the contract method 0xe8032557.
//
// Solidity: function openChannelMockSet(bytes32 _channelId, uint256 _disputeTimeout, address _tokenAddress, uint256 _tokenType, address[2] _peerAddrs, uint256[2] _deposits) returns()
func (_CelerLedger *CelerLedgerTransactor) OpenChannelMockSet(opts *bind.TransactOpts, _channelId [32]byte, _disputeTimeout *big.Int, _tokenAddress common.Address, _tokenType *big.Int, _peerAddrs [2]common.Address, _deposits [2]*big.Int) (*types.Transaction, error) {
	return _CelerLedger.contract.Transact(opts, "openChannelMockSet", _channelId, _disputeTimeout, _tokenAddress, _tokenType, _peerAddrs, _deposits)
}

// OpenChannelMockSet is a paid mutator transaction binding the contract method 0xe8032557.
//
// Solidity: function openChannelMockSet(bytes32 _channelId, uint256 _disputeTimeout, address _tokenAddress, uint256 _tokenType, address[2] _peerAddrs, uint256[2] _deposits) returns()
func (_CelerLedger *CelerLedgerSession) OpenChannelMockSet(_channelId [32]byte, _disputeTimeout *big.Int, _tokenAddress common.Address, _tokenType *big.Int, _peerAddrs [2]common.Address, _deposits [2]*big.Int) (*types.Transaction, error) {
	return _CelerLedger.Contract.OpenChannelMockSet(&_CelerLedger.TransactOpts, _channelId, _disputeTimeout, _tokenAddress, _tokenType, _peerAddrs, _deposits)
}

// OpenChannelMockSet is a paid mutator transaction binding the contract method 0xe8032557.
//
// Solidity: function openChannelMockSet(bytes32 _channelId, uint256 _disputeTimeout, address _tokenAddress, uint256 _tokenType, address[2] _peerAddrs, uint256[2] _deposits) returns()
func (_CelerLedger *CelerLedgerTransactorSession) OpenChannelMockSet(_channelId [32]byte, _disputeTimeout *big.Int, _tokenAddress common.Address, _tokenType *big.Int, _peerAddrs [2]common.Address, _deposits [2]*big.Int) (*types.Transaction, error) {
	return _CelerLedger.Contract.OpenChannelMockSet(&_CelerLedger.TransactOpts, _channelId, _disputeTimeout, _tokenAddress, _tokenType, _peerAddrs, _deposits)
}

// SnapshotStates is a paid mutator transaction binding the contract method 0x4102b9a8.
//
// Solidity: function snapshotStates(bytes _signedSimplexStateArray) returns()
func (_CelerLedger *CelerLedgerTransactor) SnapshotStates(opts *bind.TransactOpts, _signedSimplexStateArray []byte) (*types.Transaction, error) {
	return _CelerLedger.contract.Transact(opts, "snapshotStates", _signedSimplexStateArray)
}

// SnapshotStates is a paid mutator transaction binding the contract method 0x4102b9a8.
//
// Solidity: function snapshotStates(bytes _signedSimplexStateArray) returns()
func (_CelerLedger *CelerLedgerSession) SnapshotStates(_signedSimplexStateArray []byte) (*types.Transaction, error) {
	return _CelerLedger.Contract.SnapshotStates(&_CelerLedger.TransactOpts, _signedSimplexStateArray)
}

// SnapshotStates is a paid mutator transaction binding the contract method 0x4102b9a8.
//
// Solidity: function snapshotStates(bytes _signedSimplexStateArray) returns()
func (_CelerLedger *CelerLedgerTransactorSession) SnapshotStates(_signedSimplexStateArray []byte) (*types.Transaction, error) {
	return _CelerLedger.Contract.SnapshotStates(&_CelerLedger.TransactOpts, _signedSimplexStateArray)
}

// SnapshotStatesMockSet is a paid mutator transaction binding the contract method 0x14ff1491.
//
// Solidity: function snapshotStatesMockSet(bytes32[] _channelIds, address[] _peerFroms, uint256[] _seqNums, uint256[] _transferOuts, uint256[] _pendingPayOuts) returns()
func (_CelerLedger *CelerLedgerTransactor) SnapshotStatesMockSet(opts *bind.TransactOpts, _channelIds [][32]byte, _peerFroms []common.Address, _seqNums []*big.Int, _transferOuts []*big.Int, _pendingPayOuts []*big.Int) (*types.Transaction, error) {
	return _CelerLedger.contract.Transact(opts, "snapshotStatesMockSet", _channelIds, _peerFroms, _seqNums, _transferOuts, _pendingPayOuts)
}

// SnapshotStatesMockSet is a paid mutator transaction binding the contract method 0x14ff1491.
//
// Solidity: function snapshotStatesMockSet(bytes32[] _channelIds, address[] _peerFroms, uint256[] _seqNums, uint256[] _transferOuts, uint256[] _pendingPayOuts) returns()
func (_CelerLedger *CelerLedgerSession) SnapshotStatesMockSet(_channelIds [][32]byte, _peerFroms []common.Address, _seqNums []*big.Int, _transferOuts []*big.Int, _pendingPayOuts []*big.Int) (*types.Transaction, error) {
	return _CelerLedger.Contract.SnapshotStatesMockSet(&_CelerLedger.TransactOpts, _channelIds, _peerFroms, _seqNums, _transferOuts, _pendingPayOuts)
}

// SnapshotStatesMockSet is a paid mutator transaction binding the contract method 0x14ff1491.
//
// Solidity: function snapshotStatesMockSet(bytes32[] _channelIds, address[] _peerFroms, uint256[] _seqNums, uint256[] _transferOuts, uint256[] _pendingPayOuts) returns()
func (_CelerLedger *CelerLedgerTransactorSession) SnapshotStatesMockSet(_channelIds [][32]byte, _peerFroms []common.Address, _seqNums []*big.Int, _transferOuts []*big.Int, _pendingPayOuts []*big.Int) (*types.Transaction, error) {
	return _CelerLedger.Contract.SnapshotStatesMockSet(&_CelerLedger.TransactOpts, _channelIds, _peerFroms, _seqNums, _transferOuts, _pendingPayOuts)
}

// VetoWithdraw is a paid mutator transaction binding the contract method 0x255aab59.
//
// Solidity: function vetoWithdraw(bytes32 _channelId) returns()
func (_CelerLedger *CelerLedgerTransactor) VetoWithdraw(opts *bind.TransactOpts, _channelId [32]byte) (*types.Transaction, error) {
	return _CelerLedger.contract.Transact(opts, "vetoWithdraw", _channelId)
}

// VetoWithdraw is a paid mutator transaction binding the contract method 0x255aab59.
//
// Solidity: function vetoWithdraw(bytes32 _channelId) returns()
func (_CelerLedger *CelerLedgerSession) VetoWithdraw(_channelId [32]byte) (*types.Transaction, error) {
	return _CelerLedger.Contract.VetoWithdraw(&_CelerLedger.TransactOpts, _channelId)
}

// VetoWithdraw is a paid mutator transaction binding the contract method 0x255aab59.
//
// Solidity: function vetoWithdraw(bytes32 _channelId) returns()
func (_CelerLedger *CelerLedgerTransactorSession) VetoWithdraw(_channelId [32]byte) (*types.Transaction, error) {
	return _CelerLedger.Contract.VetoWithdraw(&_CelerLedger.TransactOpts, _channelId)
}

// CelerLedgerClearOnePayIterator is returned from FilterClearOnePay and is used to iterate over the raw logs and unpacked data for ClearOnePay events raised by the CelerLedger contract.
type CelerLedgerClearOnePayIterator struct {
	Event *CelerLedgerClearOnePay // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CelerLedgerClearOnePayIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CelerLedgerClearOnePay)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CelerLedgerClearOnePay)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CelerLedgerClearOnePayIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CelerLedgerClearOnePayIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CelerLedgerClearOnePay represents a ClearOnePay event raised by the CelerLedger contract.
type CelerLedgerClearOnePay struct {
	ChannelId [32]byte
	PayId     [32]byte
	PeerFrom  common.Address
	Amount    *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterClearOnePay is a free log retrieval operation binding the contract event 0x33252d4bc5cee2ad248475e8c39239a79dc64b2691c9ca1a63ff9af0c75b8776.
//
// Solidity: event ClearOnePay(bytes32 indexed channelId, bytes32 indexed payId, address indexed peerFrom, uint256 amount)
func (_CelerLedger *CelerLedgerFilterer) FilterClearOnePay(opts *bind.FilterOpts, channelId [][32]byte, payId [][32]byte, peerFrom []common.Address) (*CelerLedgerClearOnePayIterator, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}
	var payIdRule []interface{}
	for _, payIdItem := range payId {
		payIdRule = append(payIdRule, payIdItem)
	}
	var peerFromRule []interface{}
	for _, peerFromItem := range peerFrom {
		peerFromRule = append(peerFromRule, peerFromItem)
	}

	logs, sub, err := _CelerLedger.contract.FilterLogs(opts, "ClearOnePay", channelIdRule, payIdRule, peerFromRule)
	if err != nil {
		return nil, err
	}
	return &CelerLedgerClearOnePayIterator{contract: _CelerLedger.contract, event: "ClearOnePay", logs: logs, sub: sub}, nil
}

// WatchClearOnePay is a free log subscription operation binding the contract event 0x33252d4bc5cee2ad248475e8c39239a79dc64b2691c9ca1a63ff9af0c75b8776.
//
// Solidity: event ClearOnePay(bytes32 indexed channelId, bytes32 indexed payId, address indexed peerFrom, uint256 amount)
func (_CelerLedger *CelerLedgerFilterer) WatchClearOnePay(opts *bind.WatchOpts, sink chan<- *CelerLedgerClearOnePay, channelId [][32]byte, payId [][32]byte, peerFrom []common.Address) (event.Subscription, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}
	var payIdRule []interface{}
	for _, payIdItem := range payId {
		payIdRule = append(payIdRule, payIdItem)
	}
	var peerFromRule []interface{}
	for _, peerFromItem := range peerFrom {
		peerFromRule = append(peerFromRule, peerFromItem)
	}

	logs, sub, err := _CelerLedger.contract.WatchLogs(opts, "ClearOnePay", channelIdRule, payIdRule, peerFromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CelerLedgerClearOnePay)
				if err := _CelerLedger.contract.UnpackLog(event, "ClearOnePay", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CelerLedgerConfirmSettleIterator is returned from FilterConfirmSettle and is used to iterate over the raw logs and unpacked data for ConfirmSettle events raised by the CelerLedger contract.
type CelerLedgerConfirmSettleIterator struct {
	Event *CelerLedgerConfirmSettle // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CelerLedgerConfirmSettleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CelerLedgerConfirmSettle)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CelerLedgerConfirmSettle)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CelerLedgerConfirmSettleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CelerLedgerConfirmSettleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CelerLedgerConfirmSettle represents a ConfirmSettle event raised by the CelerLedger contract.
type CelerLedgerConfirmSettle struct {
	ChannelId     [32]byte
	SettleBalance [2]*big.Int
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterConfirmSettle is a free log retrieval operation binding the contract event 0x728ddd8c5acda5947c34db8d759c66ae70884f526ff9b93637d351b012ef3206.
//
// Solidity: event ConfirmSettle(bytes32 indexed channelId, uint256[2] settleBalance)
func (_CelerLedger *CelerLedgerFilterer) FilterConfirmSettle(opts *bind.FilterOpts, channelId [][32]byte) (*CelerLedgerConfirmSettleIterator, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}

	logs, sub, err := _CelerLedger.contract.FilterLogs(opts, "ConfirmSettle", channelIdRule)
	if err != nil {
		return nil, err
	}
	return &CelerLedgerConfirmSettleIterator{contract: _CelerLedger.contract, event: "ConfirmSettle", logs: logs, sub: sub}, nil
}

// WatchConfirmSettle is a free log subscription operation binding the contract event 0x728ddd8c5acda5947c34db8d759c66ae70884f526ff9b93637d351b012ef3206.
//
// Solidity: event ConfirmSettle(bytes32 indexed channelId, uint256[2] settleBalance)
func (_CelerLedger *CelerLedgerFilterer) WatchConfirmSettle(opts *bind.WatchOpts, sink chan<- *CelerLedgerConfirmSettle, channelId [][32]byte) (event.Subscription, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}

	logs, sub, err := _CelerLedger.contract.WatchLogs(opts, "ConfirmSettle", channelIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CelerLedgerConfirmSettle)
				if err := _CelerLedger.contract.UnpackLog(event, "ConfirmSettle", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CelerLedgerConfirmSettleFailIterator is returned from FilterConfirmSettleFail and is used to iterate over the raw logs and unpacked data for ConfirmSettleFail events raised by the CelerLedger contract.
type CelerLedgerConfirmSettleFailIterator struct {
	Event *CelerLedgerConfirmSettleFail // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CelerLedgerConfirmSettleFailIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CelerLedgerConfirmSettleFail)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CelerLedgerConfirmSettleFail)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CelerLedgerConfirmSettleFailIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CelerLedgerConfirmSettleFailIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CelerLedgerConfirmSettleFail represents a ConfirmSettleFail event raised by the CelerLedger contract.
type CelerLedgerConfirmSettleFail struct {
	ChannelId [32]byte
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterConfirmSettleFail is a free log retrieval operation binding the contract event 0xa6549eb18490d42e7ec93f42115d1ee11b706d04077be9597034dd73ec8bcb36.
//
// Solidity: event ConfirmSettleFail(bytes32 indexed channelId)
func (_CelerLedger *CelerLedgerFilterer) FilterConfirmSettleFail(opts *bind.FilterOpts, channelId [][32]byte) (*CelerLedgerConfirmSettleFailIterator, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}

	logs, sub, err := _CelerLedger.contract.FilterLogs(opts, "ConfirmSettleFail", channelIdRule)
	if err != nil {
		return nil, err
	}
	return &CelerLedgerConfirmSettleFailIterator{contract: _CelerLedger.contract, event: "ConfirmSettleFail", logs: logs, sub: sub}, nil
}

// WatchConfirmSettleFail is a free log subscription operation binding the contract event 0xa6549eb18490d42e7ec93f42115d1ee11b706d04077be9597034dd73ec8bcb36.
//
// Solidity: event ConfirmSettleFail(bytes32 indexed channelId)
func (_CelerLedger *CelerLedgerFilterer) WatchConfirmSettleFail(opts *bind.WatchOpts, sink chan<- *CelerLedgerConfirmSettleFail, channelId [][32]byte) (event.Subscription, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}

	logs, sub, err := _CelerLedger.contract.WatchLogs(opts, "ConfirmSettleFail", channelIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CelerLedgerConfirmSettleFail)
				if err := _CelerLedger.contract.UnpackLog(event, "ConfirmSettleFail", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CelerLedgerConfirmWithdrawIterator is returned from FilterConfirmWithdraw and is used to iterate over the raw logs and unpacked data for ConfirmWithdraw events raised by the CelerLedger contract.
type CelerLedgerConfirmWithdrawIterator struct {
	Event *CelerLedgerConfirmWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CelerLedgerConfirmWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CelerLedgerConfirmWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CelerLedgerConfirmWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CelerLedgerConfirmWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CelerLedgerConfirmWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CelerLedgerConfirmWithdraw represents a ConfirmWithdraw event raised by the CelerLedger contract.
type CelerLedgerConfirmWithdraw struct {
	ChannelId          [32]byte
	WithdrawnAmount    *big.Int
	Receiver           common.Address
	RecipientChannelId [32]byte
	Deposits           [2]*big.Int
	Withdrawals        [2]*big.Int
	Raw                types.Log // Blockchain specific contextual infos
}

// FilterConfirmWithdraw is a free log retrieval operation binding the contract event 0xe8110b4ee08638c48f6a4d5f726927df4e541893efa9d2c2c47a6b889041826e.
//
// Solidity: event ConfirmWithdraw(bytes32 indexed channelId, uint256 withdrawnAmount, address indexed receiver, bytes32 indexed recipientChannelId, uint256[2] deposits, uint256[2] withdrawals)
func (_CelerLedger *CelerLedgerFilterer) FilterConfirmWithdraw(opts *bind.FilterOpts, channelId [][32]byte, receiver []common.Address, recipientChannelId [][32]byte) (*CelerLedgerConfirmWithdrawIterator, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}

	var receiverRule []interface{}
	for _, receiverItem := range receiver {
		receiverRule = append(receiverRule, receiverItem)
	}
	var recipientChannelIdRule []interface{}
	for _, recipientChannelIdItem := range recipientChannelId {
		recipientChannelIdRule = append(recipientChannelIdRule, recipientChannelIdItem)
	}

	logs, sub, err := _CelerLedger.contract.FilterLogs(opts, "ConfirmWithdraw", channelIdRule, receiverRule, recipientChannelIdRule)
	if err != nil {
		return nil, err
	}
	return &CelerLedgerConfirmWithdrawIterator{contract: _CelerLedger.contract, event: "ConfirmWithdraw", logs: logs, sub: sub}, nil
}

// WatchConfirmWithdraw is a free log subscription operation binding the contract event 0xe8110b4ee08638c48f6a4d5f726927df4e541893efa9d2c2c47a6b889041826e.
//
// Solidity: event ConfirmWithdraw(bytes32 indexed channelId, uint256 withdrawnAmount, address indexed receiver, bytes32 indexed recipientChannelId, uint256[2] deposits, uint256[2] withdrawals)
func (_CelerLedger *CelerLedgerFilterer) WatchConfirmWithdraw(opts *bind.WatchOpts, sink chan<- *CelerLedgerConfirmWithdraw, channelId [][32]byte, receiver []common.Address, recipientChannelId [][32]byte) (event.Subscription, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}

	var receiverRule []interface{}
	for _, receiverItem := range receiver {
		receiverRule = append(receiverRule, receiverItem)
	}
	var recipientChannelIdRule []interface{}
	for _, recipientChannelIdItem := range recipientChannelId {
		recipientChannelIdRule = append(recipientChannelIdRule, recipientChannelIdItem)
	}

	logs, sub, err := _CelerLedger.contract.WatchLogs(opts, "ConfirmWithdraw", channelIdRule, receiverRule, recipientChannelIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CelerLedgerConfirmWithdraw)
				if err := _CelerLedger.contract.UnpackLog(event, "ConfirmWithdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CelerLedgerCooperativeSettleIterator is returned from FilterCooperativeSettle and is used to iterate over the raw logs and unpacked data for CooperativeSettle events raised by the CelerLedger contract.
type CelerLedgerCooperativeSettleIterator struct {
	Event *CelerLedgerCooperativeSettle // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CelerLedgerCooperativeSettleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CelerLedgerCooperativeSettle)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CelerLedgerCooperativeSettle)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CelerLedgerCooperativeSettleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CelerLedgerCooperativeSettleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CelerLedgerCooperativeSettle represents a CooperativeSettle event raised by the CelerLedger contract.
type CelerLedgerCooperativeSettle struct {
	ChannelId     [32]byte
	SettleBalance [2]*big.Int
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterCooperativeSettle is a free log retrieval operation binding the contract event 0x6c666557dc97fd52cd2d9d6dd6d109e501ffdb831abeecf13aafeeaf762ee1fd.
//
// Solidity: event CooperativeSettle(bytes32 indexed channelId, uint256[2] settleBalance)
func (_CelerLedger *CelerLedgerFilterer) FilterCooperativeSettle(opts *bind.FilterOpts, channelId [][32]byte) (*CelerLedgerCooperativeSettleIterator, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}

	logs, sub, err := _CelerLedger.contract.FilterLogs(opts, "CooperativeSettle", channelIdRule)
	if err != nil {
		return nil, err
	}
	return &CelerLedgerCooperativeSettleIterator{contract: _CelerLedger.contract, event: "CooperativeSettle", logs: logs, sub: sub}, nil
}

// WatchCooperativeSettle is a free log subscription operation binding the contract event 0x6c666557dc97fd52cd2d9d6dd6d109e501ffdb831abeecf13aafeeaf762ee1fd.
//
// Solidity: event CooperativeSettle(bytes32 indexed channelId, uint256[2] settleBalance)
func (_CelerLedger *CelerLedgerFilterer) WatchCooperativeSettle(opts *bind.WatchOpts, sink chan<- *CelerLedgerCooperativeSettle, channelId [][32]byte) (event.Subscription, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}

	logs, sub, err := _CelerLedger.contract.WatchLogs(opts, "CooperativeSettle", channelIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CelerLedgerCooperativeSettle)
				if err := _CelerLedger.contract.UnpackLog(event, "CooperativeSettle", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CelerLedgerCooperativeWithdrawIterator is returned from FilterCooperativeWithdraw and is used to iterate over the raw logs and unpacked data for CooperativeWithdraw events raised by the CelerLedger contract.
type CelerLedgerCooperativeWithdrawIterator struct {
	Event *CelerLedgerCooperativeWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CelerLedgerCooperativeWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CelerLedgerCooperativeWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CelerLedgerCooperativeWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CelerLedgerCooperativeWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CelerLedgerCooperativeWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CelerLedgerCooperativeWithdraw represents a CooperativeWithdraw event raised by the CelerLedger contract.
type CelerLedgerCooperativeWithdraw struct {
	ChannelId          [32]byte
	WithdrawnAmount    *big.Int
	Receiver           common.Address
	RecipientChannelId [32]byte
	Deposits           [2]*big.Int
	Withdrawals        [2]*big.Int
	SeqNum             *big.Int
	Raw                types.Log // Blockchain specific contextual infos
}

// FilterCooperativeWithdraw is a free log retrieval operation binding the contract event 0x1b87d077d9b706e42883b454b67730633fd6b4b29f9a9cf5f57c278c54f51c8f.
//
// Solidity: event CooperativeWithdraw(bytes32 indexed channelId, uint256 withdrawnAmount, address indexed receiver, bytes32 indexed recipientChannelId, uint256[2] deposits, uint256[2] withdrawals, uint256 seqNum)
func (_CelerLedger *CelerLedgerFilterer) FilterCooperativeWithdraw(opts *bind.FilterOpts, channelId [][32]byte, receiver []common.Address, recipientChannelId [][32]byte) (*CelerLedgerCooperativeWithdrawIterator, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}

	var receiverRule []interface{}
	for _, receiverItem := range receiver {
		receiverRule = append(receiverRule, receiverItem)
	}
	var recipientChannelIdRule []interface{}
	for _, recipientChannelIdItem := range recipientChannelId {
		recipientChannelIdRule = append(recipientChannelIdRule, recipientChannelIdItem)
	}

	logs, sub, err := _CelerLedger.contract.FilterLogs(opts, "CooperativeWithdraw", channelIdRule, receiverRule, recipientChannelIdRule)
	if err != nil {
		return nil, err
	}
	return &CelerLedgerCooperativeWithdrawIterator{contract: _CelerLedger.contract, event: "CooperativeWithdraw", logs: logs, sub: sub}, nil
}

// WatchCooperativeWithdraw is a free log subscription operation binding the contract event 0x1b87d077d9b706e42883b454b67730633fd6b4b29f9a9cf5f57c278c54f51c8f.
//
// Solidity: event CooperativeWithdraw(bytes32 indexed channelId, uint256 withdrawnAmount, address indexed receiver, bytes32 indexed recipientChannelId, uint256[2] deposits, uint256[2] withdrawals, uint256 seqNum)
func (_CelerLedger *CelerLedgerFilterer) WatchCooperativeWithdraw(opts *bind.WatchOpts, sink chan<- *CelerLedgerCooperativeWithdraw, channelId [][32]byte, receiver []common.Address, recipientChannelId [][32]byte) (event.Subscription, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}

	var receiverRule []interface{}
	for _, receiverItem := range receiver {
		receiverRule = append(receiverRule, receiverItem)
	}
	var recipientChannelIdRule []interface{}
	for _, recipientChannelIdItem := range recipientChannelId {
		recipientChannelIdRule = append(recipientChannelIdRule, recipientChannelIdItem)
	}

	logs, sub, err := _CelerLedger.contract.WatchLogs(opts, "CooperativeWithdraw", channelIdRule, receiverRule, recipientChannelIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CelerLedgerCooperativeWithdraw)
				if err := _CelerLedger.contract.UnpackLog(event, "CooperativeWithdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CelerLedgerDepositIterator is returned from FilterDeposit and is used to iterate over the raw logs and unpacked data for Deposit events raised by the CelerLedger contract.
type CelerLedgerDepositIterator struct {
	Event *CelerLedgerDeposit // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CelerLedgerDepositIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CelerLedgerDeposit)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CelerLedgerDeposit)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CelerLedgerDepositIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CelerLedgerDepositIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CelerLedgerDeposit represents a Deposit event raised by the CelerLedger contract.
type CelerLedgerDeposit struct {
	ChannelId   [32]byte
	PeerAddrs   [2]common.Address
	Deposits    [2]*big.Int
	Withdrawals [2]*big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterDeposit is a free log retrieval operation binding the contract event 0xb63f5dc096f516663ffb5ef2b611f0e2acca8617a868c2a3653cba5e3ed0e92c.
//
// Solidity: event Deposit(bytes32 indexed channelId, address[2] peerAddrs, uint256[2] deposits, uint256[2] withdrawals)
func (_CelerLedger *CelerLedgerFilterer) FilterDeposit(opts *bind.FilterOpts, channelId [][32]byte) (*CelerLedgerDepositIterator, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}

	logs, sub, err := _CelerLedger.contract.FilterLogs(opts, "Deposit", channelIdRule)
	if err != nil {
		return nil, err
	}
	return &CelerLedgerDepositIterator{contract: _CelerLedger.contract, event: "Deposit", logs: logs, sub: sub}, nil
}

// WatchDeposit is a free log subscription operation binding the contract event 0xb63f5dc096f516663ffb5ef2b611f0e2acca8617a868c2a3653cba5e3ed0e92c.
//
// Solidity: event Deposit(bytes32 indexed channelId, address[2] peerAddrs, uint256[2] deposits, uint256[2] withdrawals)
func (_CelerLedger *CelerLedgerFilterer) WatchDeposit(opts *bind.WatchOpts, sink chan<- *CelerLedgerDeposit, channelId [][32]byte) (event.Subscription, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}

	logs, sub, err := _CelerLedger.contract.WatchLogs(opts, "Deposit", channelIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CelerLedgerDeposit)
				if err := _CelerLedger.contract.UnpackLog(event, "Deposit", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CelerLedgerIntendSettleIterator is returned from FilterIntendSettle and is used to iterate over the raw logs and unpacked data for IntendSettle events raised by the CelerLedger contract.
type CelerLedgerIntendSettleIterator struct {
	Event *CelerLedgerIntendSettle // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CelerLedgerIntendSettleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CelerLedgerIntendSettle)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CelerLedgerIntendSettle)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CelerLedgerIntendSettleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CelerLedgerIntendSettleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CelerLedgerIntendSettle represents a IntendSettle event raised by the CelerLedger contract.
type CelerLedgerIntendSettle struct {
	ChannelId [32]byte
	SeqNums   [2]*big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterIntendSettle is a free log retrieval operation binding the contract event 0x296143e7e25aa055fbb871702776a67da540876e2be721d5c38ba23c97c90d64.
//
// Solidity: event IntendSettle(bytes32 indexed channelId, uint256[2] seqNums)
func (_CelerLedger *CelerLedgerFilterer) FilterIntendSettle(opts *bind.FilterOpts, channelId [][32]byte) (*CelerLedgerIntendSettleIterator, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}

	logs, sub, err := _CelerLedger.contract.FilterLogs(opts, "IntendSettle", channelIdRule)
	if err != nil {
		return nil, err
	}
	return &CelerLedgerIntendSettleIterator{contract: _CelerLedger.contract, event: "IntendSettle", logs: logs, sub: sub}, nil
}

// WatchIntendSettle is a free log subscription operation binding the contract event 0x296143e7e25aa055fbb871702776a67da540876e2be721d5c38ba23c97c90d64.
//
// Solidity: event IntendSettle(bytes32 indexed channelId, uint256[2] seqNums)
func (_CelerLedger *CelerLedgerFilterer) WatchIntendSettle(opts *bind.WatchOpts, sink chan<- *CelerLedgerIntendSettle, channelId [][32]byte) (event.Subscription, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}

	logs, sub, err := _CelerLedger.contract.WatchLogs(opts, "IntendSettle", channelIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CelerLedgerIntendSettle)
				if err := _CelerLedger.contract.UnpackLog(event, "IntendSettle", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CelerLedgerIntendWithdrawIterator is returned from FilterIntendWithdraw and is used to iterate over the raw logs and unpacked data for IntendWithdraw events raised by the CelerLedger contract.
type CelerLedgerIntendWithdrawIterator struct {
	Event *CelerLedgerIntendWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CelerLedgerIntendWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CelerLedgerIntendWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CelerLedgerIntendWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CelerLedgerIntendWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CelerLedgerIntendWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CelerLedgerIntendWithdraw represents a IntendWithdraw event raised by the CelerLedger contract.
type CelerLedgerIntendWithdraw struct {
	ChannelId [32]byte
	Receiver  common.Address
	Amount    *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterIntendWithdraw is a free log retrieval operation binding the contract event 0x97883669625c4ff7f5432b4ca33fe75fb5fee985deb196a967e5758f846170fe.
//
// Solidity: event IntendWithdraw(bytes32 indexed channelId, address indexed receiver, uint256 amount)
func (_CelerLedger *CelerLedgerFilterer) FilterIntendWithdraw(opts *bind.FilterOpts, channelId [][32]byte, receiver []common.Address) (*CelerLedgerIntendWithdrawIterator, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}
	var receiverRule []interface{}
	for _, receiverItem := range receiver {
		receiverRule = append(receiverRule, receiverItem)
	}

	logs, sub, err := _CelerLedger.contract.FilterLogs(opts, "IntendWithdraw", channelIdRule, receiverRule)
	if err != nil {
		return nil, err
	}
	return &CelerLedgerIntendWithdrawIterator{contract: _CelerLedger.contract, event: "IntendWithdraw", logs: logs, sub: sub}, nil
}

// WatchIntendWithdraw is a free log subscription operation binding the contract event 0x97883669625c4ff7f5432b4ca33fe75fb5fee985deb196a967e5758f846170fe.
//
// Solidity: event IntendWithdraw(bytes32 indexed channelId, address indexed receiver, uint256 amount)
func (_CelerLedger *CelerLedgerFilterer) WatchIntendWithdraw(opts *bind.WatchOpts, sink chan<- *CelerLedgerIntendWithdraw, channelId [][32]byte, receiver []common.Address) (event.Subscription, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}
	var receiverRule []interface{}
	for _, receiverItem := range receiver {
		receiverRule = append(receiverRule, receiverItem)
	}

	logs, sub, err := _CelerLedger.contract.WatchLogs(opts, "IntendWithdraw", channelIdRule, receiverRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CelerLedgerIntendWithdraw)
				if err := _CelerLedger.contract.UnpackLog(event, "IntendWithdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CelerLedgerOpenChannelIterator is returned from FilterOpenChannel and is used to iterate over the raw logs and unpacked data for OpenChannel events raised by the CelerLedger contract.
type CelerLedgerOpenChannelIterator struct {
	Event *CelerLedgerOpenChannel // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CelerLedgerOpenChannelIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CelerLedgerOpenChannel)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CelerLedgerOpenChannel)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CelerLedgerOpenChannelIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CelerLedgerOpenChannelIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CelerLedgerOpenChannel represents a OpenChannel event raised by the CelerLedger contract.
type CelerLedgerOpenChannel struct {
	ChannelId       [32]byte
	TokenType       *big.Int
	TokenAddress    common.Address
	PeerAddrs       [2]common.Address
	InitialDeposits [2]*big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterOpenChannel is a free log retrieval operation binding the contract event 0x9d9f66221370175606b4085f28a419b201c9b6dafd9e0c4520e5bf69ea3e166d.
//
// Solidity: event OpenChannel(bytes32 indexed channelId, uint256 tokenType, address indexed tokenAddress, address[2] peerAddrs, uint256[2] initialDeposits)
func (_CelerLedger *CelerLedgerFilterer) FilterOpenChannel(opts *bind.FilterOpts, channelId [][32]byte, tokenAddress []common.Address) (*CelerLedgerOpenChannelIterator, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}

	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _CelerLedger.contract.FilterLogs(opts, "OpenChannel", channelIdRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return &CelerLedgerOpenChannelIterator{contract: _CelerLedger.contract, event: "OpenChannel", logs: logs, sub: sub}, nil
}

// WatchOpenChannel is a free log subscription operation binding the contract event 0x9d9f66221370175606b4085f28a419b201c9b6dafd9e0c4520e5bf69ea3e166d.
//
// Solidity: event OpenChannel(bytes32 indexed channelId, uint256 tokenType, address indexed tokenAddress, address[2] peerAddrs, uint256[2] initialDeposits)
func (_CelerLedger *CelerLedgerFilterer) WatchOpenChannel(opts *bind.WatchOpts, sink chan<- *CelerLedgerOpenChannel, channelId [][32]byte, tokenAddress []common.Address) (event.Subscription, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}

	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _CelerLedger.contract.WatchLogs(opts, "OpenChannel", channelIdRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CelerLedgerOpenChannel)
				if err := _CelerLedger.contract.UnpackLog(event, "OpenChannel", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CelerLedgerSnapshotStatesIterator is returned from FilterSnapshotStates and is used to iterate over the raw logs and unpacked data for SnapshotStates events raised by the CelerLedger contract.
type CelerLedgerSnapshotStatesIterator struct {
	Event *CelerLedgerSnapshotStates // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CelerLedgerSnapshotStatesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CelerLedgerSnapshotStates)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CelerLedgerSnapshotStates)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CelerLedgerSnapshotStatesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CelerLedgerSnapshotStatesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CelerLedgerSnapshotStates represents a SnapshotStates event raised by the CelerLedger contract.
type CelerLedgerSnapshotStates struct {
	ChannelId [32]byte
	SeqNums   [2]*big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterSnapshotStates is a free log retrieval operation binding the contract event 0xd0793cc4198bf052a6d91a9a1273c4af39f02a91b0e19029477511c278c5b271.
//
// Solidity: event SnapshotStates(bytes32 indexed channelId, uint256[2] seqNums)
func (_CelerLedger *CelerLedgerFilterer) FilterSnapshotStates(opts *bind.FilterOpts, channelId [][32]byte) (*CelerLedgerSnapshotStatesIterator, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}

	logs, sub, err := _CelerLedger.contract.FilterLogs(opts, "SnapshotStates", channelIdRule)
	if err != nil {
		return nil, err
	}
	return &CelerLedgerSnapshotStatesIterator{contract: _CelerLedger.contract, event: "SnapshotStates", logs: logs, sub: sub}, nil
}

// WatchSnapshotStates is a free log subscription operation binding the contract event 0xd0793cc4198bf052a6d91a9a1273c4af39f02a91b0e19029477511c278c5b271.
//
// Solidity: event SnapshotStates(bytes32 indexed channelId, uint256[2] seqNums)
func (_CelerLedger *CelerLedgerFilterer) WatchSnapshotStates(opts *bind.WatchOpts, sink chan<- *CelerLedgerSnapshotStates, channelId [][32]byte) (event.Subscription, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}

	logs, sub, err := _CelerLedger.contract.WatchLogs(opts, "SnapshotStates", channelIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CelerLedgerSnapshotStates)
				if err := _CelerLedger.contract.UnpackLog(event, "SnapshotStates", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CelerLedgerVetoWithdrawIterator is returned from FilterVetoWithdraw and is used to iterate over the raw logs and unpacked data for VetoWithdraw events raised by the CelerLedger contract.
type CelerLedgerVetoWithdrawIterator struct {
	Event *CelerLedgerVetoWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CelerLedgerVetoWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CelerLedgerVetoWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CelerLedgerVetoWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CelerLedgerVetoWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CelerLedgerVetoWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CelerLedgerVetoWithdraw represents a VetoWithdraw event raised by the CelerLedger contract.
type CelerLedgerVetoWithdraw struct {
	ChannelId [32]byte
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterVetoWithdraw is a free log retrieval operation binding the contract event 0x9a8a5493b616f074b3f754b5fd66049c8e7980f01547289e5e31808485c6002c.
//
// Solidity: event VetoWithdraw(bytes32 indexed channelId)
func (_CelerLedger *CelerLedgerFilterer) FilterVetoWithdraw(opts *bind.FilterOpts, channelId [][32]byte) (*CelerLedgerVetoWithdrawIterator, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}

	logs, sub, err := _CelerLedger.contract.FilterLogs(opts, "VetoWithdraw", channelIdRule)
	if err != nil {
		return nil, err
	}
	return &CelerLedgerVetoWithdrawIterator{contract: _CelerLedger.contract, event: "VetoWithdraw", logs: logs, sub: sub}, nil
}

// WatchVetoWithdraw is a free log subscription operation binding the contract event 0x9a8a5493b616f074b3f754b5fd66049c8e7980f01547289e5e31808485c6002c.
//
// Solidity: event VetoWithdraw(bytes32 indexed channelId)
func (_CelerLedger *CelerLedgerFilterer) WatchVetoWithdraw(opts *bind.WatchOpts, sink chan<- *CelerLedgerVetoWithdraw, channelId [][32]byte) (event.Subscription, error) {

	var channelIdRule []interface{}
	for _, channelIdItem := range channelId {
		channelIdRule = append(channelIdRule, channelIdItem)
	}

	logs, sub, err := _CelerLedger.contract.WatchLogs(opts, "VetoWithdraw", channelIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CelerLedgerVetoWithdraw)
				if err := _CelerLedger.contract.UnpackLog(event, "VetoWithdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}
